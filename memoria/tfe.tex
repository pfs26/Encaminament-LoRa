\documentclass{tfgitic}[2024/07/01]
% « »
% Aqui carregueu packages complementaris que necessiteu
\usepackage[utf8]{inputenc}
\usepackage{biblatex}
% \usepackage[table,xcdraw]{xcolor}
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{hhline}
\usepackage{caption}
\usepackage{bytefield}


\usepackage{makecell}
\usepackage{array}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{vcell}
\usepackage{rotating}

\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, calc, decorations.markings, shapes.geometric}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=2cm, minimum height=1cm,text centered, draw=black, fill=gray!30]
\tikzstyle{process} = [rectangle, minimum width=2, minimum height=1cm, text centered, draw=black, fill=blue!20]
\tikzstyle{decision} = [diamond, minimum width=2.5cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\renewcommand{\figureautorefname}{figura}
\renewcommand{\tableautorefname}{taula}
\renewcommand{\sectionautorefname}{secció}
\renewcommand{\subsectionautorefname}{apartat}
\renewcommand{\subsubsectionautorefname}{subapartat}
\renewcommand{\chapterautorefname}{capítol}


\tikzset{
  cross at end/.style={
    postaction={
      decorate,
      decoration={
        markings,
        mark=at position 1 with {
          \draw[solid, line width=0.6pt, color=black]
            (-2pt,-2pt) -- (2pt,2pt)
            (-2pt,2pt) -- (2pt,-2pt);
        }
      }
    }
  }
}

% Indica quines bd bibliografiques usarem
\addbibresource{tfe.bib}

% \title{Disseny d’un protocol LoRa amb encaminament estàtic per aplicacions de monitoratge}
\title{Disseny d’un protocol LoRa amb encaminament estàtic per aplicacions de monitoratge}
\subtitle{Aplicació en xarxes de baix consum mitjançant sincronització temporal}
% \subtitle{Adaptació per a escenaris de baix consum mitjançant sincronització temporal}

% L'autor del treball. Admet gènere (vegeu 9.2 del manual) fent \author[f]{}
\author{Pol Flotats Sabata}

% La direcció. Un treball ordinari te un o excepcionalment dos directors.
% admet gènerer i número (vegeu 9.2 del manual)
\advisor{Jordi Bonet Dalmau i Arnau Arumi Casanovas}

% Si el treball es fa sota un conveni de pràctiques (modalitat empresa)
% llavors el director (advisor) és la persona de la empresa que
% dirigeix el treball i, a més, hi ha un professor que fa de tutor (counselor).
% En aquest cas també es consigna l'empresa (company)
% \counselor admet gènere (vegeu 9.2 del manual)
%
% \counselor{}
% \company{}

% Els àmbits temàtics en que es classifica el treball. Pregunteu al
% director.
\topics{}

% Si voleu dedicatòria descomenteu
%\dedication{}

% Si voleu agraïments descomenteu
%\begin{acknowledgments}
%\end{acknowledgments}


\begin{resum}
\end{resum}

\begin{abstract}
\end{abstract}




\begin{document}

% Si feu servir apèndixs, descomenteu
%\part{Memòria}

\chapter{Introducció}
\section{Objectius}
\section{Limitacions i abast del treball}
\section{Estructura de la memòria}
% primera part on es fa disseny d'un protocol genèric i NO centrat en baix consum, sinó en generalització i nodes amb taules estàtiques
% segona part on es fa un disseny centrat en baix consum i sincronització temporal

\chapter{Antecedents}
\section{Protocols de comunicació: capes i modularitat}
\label{sec:protocols}
Un protocol de comunicació defineix com dos o més dispositius d'una xarxa poden intercanviar informació. Ho fa mitjançant regles i normes que determinen la sintaxi ---format dels missatges---, la semàntica ---el seu significat---, i mecanismes de detecció i correcció d'errors.

Per tal que es pugui establir una comunicació, és necessari que els dispositius involucrats implementin el mateix protocol. Per facilitar-ho, es defineixen estàndards tècnics, publicats per organitzacions com l'\acro{iso} o l'\acro{ieee}, permetent que els fabricants puguin dissenyar dispositius compatibles. Un exemple de protocol estandaritzat és \acro{http}, amb el seu detall consultable a \cite{fielding_hypertext_2014}.

Per facilitar el disseny i implementació dels protocols, sovint es descomposen en protocols més simples. Aquests es poden agrupar en capes, on cada capa s'encarrega d'una part específica del procés de comunicació. El resultat és el que es coneix com una pila de protocols. 
En aquests dissenys, cada capa depèn de les capes inferiors per realitzar les seves funcions, i proporciona serveis a les capes superiors. El disseny i verificació de cada capa es pot fer de forma independent, i ofereixen la possibilitat d'implementar diferents protocols en cada capa, sempre que es mantingui la interfície definida entre elles.

Un dels models més coneguts és el model \acro{osi}, definit per set capes. Tot i no ser utilitzat en sistemes reals, és de gran utilitat en entorns acadèmics per comprendre la divisió per capes. Per a més informació, es pot consultar \cite{noauthor_isoiec_1994}.

En sistemes reals, el model més utilitzat és el model \acro{tcp/ip}, que estableix les bases d'Internet. Està format per quatre capes:
\begin{enumerate}
    \item \emph{Enllaç}. És la capa de més baix nivell. S'encarrega de la comunicació entre dispositius d'una mateixa xarxa ---és a dir, es poden comunicar directament---, i de la detecció i correció d'errors produits en la comunicació. També gestiona l'accés al medi físic per on es transmeten les dades, que sovint és compartit amb altres dispositius.
    \item \emph{Xarxa}. Gestiona la comunicació entre dispositius que es troben en xarxes diferents i, per tant, no es poden comunicar directament. Per fer-ho, s'utilitzen dispositius intermedis, coneguts com a encaminadors (\est{routers}), que determinen la ruta més eficient per fer arribar les dades al seu destí.
    \item \emph{Transport}. Defineix la connexió d'extrem a extrem entre els dispositius origen i destí i, si és necessari, que la transmissió sigui fiable. Els protocols d'aquesta capa poden oferir mecanismes com l'ordenació de missatges, l'eliminació de missatges duplicats i la gestió de congestió. Els dos protocols més coneguts d'aquesta capa són \acro{tcp}, que garanteix la transmissió fiable de dades mitjançant confirmacions i retransmissions, i \acro{udp}, que no garanteix fiabilitat, però és més eficient per aplicacions en temps real com el contingut en estríming o videjocs.
    \item \emph{Aplicació}. És la capa més alta i propera a l'usuari final. Defineix els protocols que utilitzen les aplicacions per comunicar-se a través de la xarxa, com ara \acro{http}, utilitzat per a la navegació web, o protocols de suport, com ara \acro{dns}, per a la resolució de noms de domini.
\end{enumerate}
Per a l'estàndard complet i més detall, es pot consultar \cite{braden_requirements_1989}. 

% \subsection{Referència al model TCP/IP}
\section{Tecnologia LoRa i LoRaWAN}
Els termes \emph{LoRa} i \emph{LoRaWAN} sovint es confonen i s'utilitzen ambdós termes indistintament. Mentre que el primer és una tecnologia propietària, el segon és mantingut per una associació sense ànim de lucre. En aquest apartat es presenten ambdues tecnologies, indicant-ne les seves característiques i limitacions.

\subsection{LoRa}
% TODO: Explicar estructura missatge LoRa? Preambul?
% Mencionar mida màxima de les dades?
El nom de \emph{LoRa} prové de l'anglès \est{Long Range}. És una tecnologia de comunicació sense fils, de llarg abast, i de baix consum, fent que sigui especialment útil per a aplicacions d'Internet de les Coses (\acro{iot}). Va ser desenvolupada per \emph{Cycleo}, que va ser adquirida per \emph{Semtech} el 2012.

Utilitza freqüència sub-GHz en bandes \acro{ism} ---\emph{Industrial, Scientific and Medical}---, que són bandes de freqüència lliures de llicència. Això permet que qualsevol persona pugui utilitzar la tecnologia sense necessitat d'obtenir una llicència. Malgrat això, existeixen limitacions legals, com la potència màxima de transmissió o la quantitat de dades que es poden transmetre en un període de temps determinat. Per a més informació, es pot consultar \ref{subsec:limitacions_legals}.

Per assolir una comunicació de llarg abast, LoRa utilitza modulació de \emph{chirp spread spectrum} (\acro{css}), que permet una comunicació robusta i fiable en entorns amb interferències. Aquesta modulació es basa en codificar cada símbol com un senyal que s'escampa per tot l'ample de banda disponible, augmentant (o disminuint) de forma lineal la freqüència al llarg del temps. Gràcies a que la freqüència varia de forma lineal, també és resistent a l'efecte \emph{Doppler}, com s'ha estudiat a \cite{doroshkin_experimental_2019}. Una representació visual del funcionament de la modulació \acro{css} es pot veure a \cite{richard_wenner_lora_2017}.

Consta de diversos paràmetres que es poden ajustar per adaptar la comunicació a diferents necessitats:
\begin{itemize}
    \item \emph{Ample de banda}. És l'ample de banda (\acro{bw}) del canal de transmissió, sovint de \SI{125}{\kHz}, però també pot ser de \SI{250}{\kHz} o \SI{500}{\kHz}. Un ample de banda més gran permet una major velocitat de transmissió, però redueix la sensibilitat de recepció i, per tant, el rang de comunicació.
    \item \emph{Data rate}. És la velocitat de transmissió de dades (\acro{dr}), que depèn de l'ample de banda i del factor d'espargiment. Un data rate més alt permet una major velocitat de transmissió, però redueix la sensibilitat de recepció i, per tant, el rang de comunicació.
    \item \emph{Spreading Factor}. El factor d'espargiment (\acro{sf}) defineix la durada dels símbols i, per tant, la velocitat de transmissió. Es correspon amb la quantitat de bits d'informació que codifica cada símbol. Un \acro{sf} més alt permet una major sensibilitat de recepció, ja que cada símbol ocupa més temps i, per tant, és més fàcil de detectar. Això permet una comunicació a llarg abast, però redueix la velocitat de transmissió. Els valors possibles de \acro{sf} són entre 7 i 12 i, per cada increment de 1 d'\acro{sf}, es redueix la velocitat de transmissió a la meitat. Una característica molt important és que els diferents \acro{sf} són ortogonals entre ells. Això implica que senyals modulats amb diferents \acro{sf} i en un mateix canal no interfereixin entre ells. 
    \item \emph{Coding Rate}. La taxa de codificació (\acro{cr}) defineix la proporció d'informació útil que es transmet en comparació amb la quantitat total de dades enviades. Els possibles valors són $\frac{4}{5}$, $\frac{4}{6}$, $\frac{4}{7}$ i $\frac{4}{8}$. Així, per un \acro{cr} de $\frac{4}{5}$, per cada quatre bits d'informació útil, se n'afegeix un de redundància.
\end{itemize}

Tots aquests paràmetres estan relacionats entre ells, i és important trobar un equilibri entre ells per aconseguir la millor comunicació possible. Per exemple, si es vol obtenir una comunicació a llarg abast, es pot augmentar el \acro{sf} i el \acro{cr}. Això reduirà la velocitat de transmissió i, per tant, augmentarà el consum energètic, ja que serà necessari estar transmetent més temps. En canvi, si es vol una comunicació ràpida, es pot reduir el \acro{sf} i augmentar el \acro{bw}, però això reduirà el rang de comunicació.

Amb una configuració adequada, es poden aconseguir comunicacions de fins a quinze quilòmetres en entorns rurals, i amb una vida útil de les bateries de diversos mesos i anys, com especifica Semtech a \cite{noauthor_lora_2024}.

Per tal que el transmissor i el receptor es puguin sincronitzar, LoRa utilitza un preàmbul de sincronització. Aquest preàmbul és un senyal de referència que permet al receptor detectar l'inici d'una transmissió i sincronitzar-se amb el transmissor. La durada del preàmbul és configurable, però sovint s'estableix de vuit símbols. Una durada major ofereix més garenties que el receptor pugui detectar la transmissió, però augmenta el temps total de transmissió i, per tant, el consum energètic.

Després de transmetre el preàmbul, es transmeten les dades del missatge. Un fet a tenir en compte és que, ja que està pensat per a ser utilitzat en dispositius de baix consum, i a la baixa velocitat de transmissió, la quantitat màxima de dades que molts transductors permeten enviar és de \SI{255}{\byte}.

Per assegurar la integritat de les dades rebudes, LoRa ofereix la possibilitat d'incloure un codi de detecció d'errors (\acro{crc}). Aquest codi es calcula a partir de les dades del missatge i s'afegeix al final del missatge. El receptor pot utilitzar aquest codi per verificar si les dades rebudes són correctes. Si el codi no coincideix amb les dades rebudes, el receptor pot descartar el missatge.


\subsection{LoRaWAN}
% TODO: QUEDA EXPLICAR JOIN (OTAA I ABP)
Pel que fa a LoRaWAN, es tracta d'una definició de l'arquitectura d'un sistema \acro{LPWAN} (\est{Low Power Wide Area Network}), desenvolupada i mantenida per la \href{https://lora-alliance.org}{LoRa Alliance}. Defineix el protocol de comunicació i l'arquitectura de la xarxa, així com els mecanismes de seguretat i gestió de la xarxa. 

Utilitzant l'estructura per capes vista a la \autoref{sec:protocols}, LoRaWAN opera principalment a nivell d'enllaç, malgrat que també implementa característiques d'altres capes (com ara el control de sessions). A nivell físic, utilitza la modulació LoRa.

Pel que fa a l'estructura de la xarxa, consta de 4 components principals:
\begin{itemize}
    \item \emph{Dispositius finals}. Sensors o actuadors que transmeten, a través de LoRa, missatges als \est{gateways}, conegut com a \est{uplinks}. També pot ser a l'inrevés, on els \est{gateways} transmeten missatges als dispositius finals, conegut com a \est{downlinks}.  
    \item \emph{Gateways}. Dispositius que reben els missatges dels dispositius finals i els transmeten al servidor de la xarxa. La comunicació entre els \est{gateways} i el servidor de la xarxa es realitza a través d'Internet, i no utilitza LoRa. 
    \item \emph{Servidor de la xarxa}. Dispositiu que gestiona els dispositius finals, els \est{gateways} i aplicacions de la xarxa. S'encarrega de la gestió de les comunicacions, la seguretat i la configuració dels dispositius finals. Gestionen també el xifrat punt a punt ---entre dispositius finals i servidors d'aplicació---.
    \item \emph{Servidor d'aplicació}. Processa les dades d'aplicació enviades pels dispositius finals.
\end{itemize}
Aquests dispositius es troben organitzats en una estructura d'«estrella d'estrelles», on a la part central hi trobem el servidor de la xarxa. Aquest es comunica amb múltiples \est{gateways}, i cada \est{gateway} es comunica a la vegada amb múltiples dispositius finals. 
Un fet important és que un dispositiu final no escull el \est{gateway} amb qui comunicar-se: en transmetre, tots els \est{gateways} que reben les dades ho reenvien al servidor de la xarxa. El servidor de xarxa és qui s'encarrega de detecar missatges duplicats i escollir quin és el millor \est{gateway} per transmetre un \est{downlink}. Aquesta estructura simplifica el disseny dels dispositius finals, amb el cost d'una major complexitat en el servidor de xarxa, tenint en compte que hi ha un únic servidor de xarxa per una quantitat N de dispositius finals.

Els dispositius finals poden operar en tres modes diferents, coneguts com a \emph{classes}:
\begin{itemize}
    \item \emph{Classe A}. És la classe més senzilla i de menor consum. Els dispositius finals només poden rebre missatges després d'haver realitzat una transmissió (\est{uplink}), moment en el qual obren dues finestres de recepció per rebre \est{downlinks}. Aquesta és la classe més utilitzada en aplicacions d'\acro{iot}, ja que permet un funcionament de baix consum, sent únicament necessari posar-se en mode de recepció després de fer una transmissió.
    \item \emph{Classe B}. Els dispositius finals obren finestres de recepció en moments predeterminats (coneguts com a \est{ping slots}), a més de les finestres de recepció que obren després d'un \est{uplink}. Aquest fet fa que la latència de recepció de \est{downlinks} sigui molt menor que en la classe A.
    \item \emph{Classe C}. Obren també dues finestres de recepció després d'un \est{uplink}, amb la diferència que la segona finestra es manté oberta fins la següent transmissió. Així, es pot considerar que aquests dispositius sempre estan rebent, amb l'exepció de quan transmeten. La latència de recepció de \est{downlinks} és la mínima d'entre les tres classes, però el consum energètic és màxim.
\end{itemize}

Una altra característica important de LoRaWAN és la seva capacitat d'autoajustament, conegut com a \acro{adr} (\est{Adaptative Data Rate}). Els dispositius finals poden ajustar automàticament els paràmetres de comunicació, com el \acro{sf} o la potència de transmissió, per adaptar-se a les condicions del canal de comunicació. Quan s'utilitza, el servidor de la xarxa pot indicar als dispositius finals quins paràmetres utilitzar, reduint el consum energètic i possibles interferències amb altres dispositius. Per exemple, un dispositiu molt proper a un \est{gateway} hauria d'utilitzar \acro{sf} més baixos, mentre que dispositius llunyans n'haurien d'utilitzar de més elevats.

\subsection{The Things Network}
Es tracta d'un projecte d'\acro{iot} que proporciona un servidor de xarxa públic i gratuït. El seu objectiu és crear una xarxa global de dispositius LoRaWAN, permetent la comunicació entre ells sense necessitat d'infraestructura pròpia. Els usuaris poden connectar els seus \est{gateways} a la xarxa i compartir la seva cobertura amb altres usuaris.

També ofereix la possibilitat d'afegir dispositius finals a la xarxa, i gestionar-los a través de la seva interfície web. A més, permeten la integració amb altres serveis, com ara \emph{Node-RED} o \emph{Grafana}, per visualitzar i analitzar les dades dels dispositius finals.

\subsection{Limitacions legals}
\label{subsec:limitacions_legals}
Com s'ha comentat anteriorment, LoRa utilitza bandes de freqüència lliures de llicència. Per garantir un ús adequat d'aquestes bandes, cada país estableix una sèrie de limitacions legals. Aquestes limitacions poden variar d'un país a un altre, i és important tenir-les en compte a l'hora de dissenyar un sistema de comunicació LoRa. 

Pel que fa a la Unió Europea, l'entitat responsable de la regulació de les comunicacions és l'\acro{etsi} (\est{European Telecommunications Standards Institute}). Estableix l'ús de LoRa en les freqüències entre \SI{863}{\MHz} i \SI{870}{\MHz}, amb un ample de banda màxim de \SI{250}{\kHz}.

A més, estableix un límit de potència màxima de transmissió, i un màxim d'utilització del canal. Aquestes limitacions depenen de la sub-banda utilitzada (dins el rang anteriorment mencionat), però de forma genèrica es considera una potència màxima de \SI{16}{\deci\bel\text{m}}, i una utilització màxima del canal (conegut com a \emph{duty cyle}) de l'\SI{1}{\%}. Així, per cada hora de funcionament, poden transmetre un màxim de 36 segons. Tots els detalls sobre les limitacions legals a la Unió Europea es poden consultar a \cite{etsi_etsi_nodate}.

Si s'utilitza un servidor de xarxa públic com \emph{The Things Network}, és important tenir en compte que aquest també pot aplicar limitacions addicionals. Pel que fa a \acro{ttn}, estableix una política d'ús just (\emph{fair use policy}) que limita l'ús del canal en 30 segons per dispositiu final i dia. A més, s'estableix un límit de deu \est{downlinks} per dispositiu i dia. És important tenir aquestes limitacions en compte en dissenyar un sistema; en cas d'incumpliment, el servidor de xarxa podria bloquejar l'accés del dispositiu final.

\section{Treballs relacionats}
\label{sec:treballs_relacionats}
Existeixen diversos projectes amb un objectiu similar al d'aquest treball, com ara \emph{Meshtastic} o \emph{LoRaMesher}. Tots dos projectes utilitzen LoRa per crear xarxes de comunicació entre dispositius finals, però presenten diferencies amb els objectius d'aquest treball. A més, consten també de limitacions, a les qual se'ls vol donar solució. En aquest apartat es presenten ambdós projectes, amb les seves característiques i limitacions, així com diferències vers el treball presentat. 

\subsection{Meshtastic}
Es tracta d'un projecte de codi obert que té com a objectiu crear una xarxa de comunicació descentralitzada, i pensada per a ser utilitzada en dispositius de baix consum i cost. El seu repositori es troba disponible a \href{https://github.com/meshtastic}{GitHub}.

Utilitza comunicació LoRa per a transmetre missatges entre dispositius, evitant dependre d'altres infraestructures com internet. Per tal d'aconseguir-ho, tots els dispositius actuen com a encaminadors: quan reben un missatge que no està destinat a ells, el reenvien, permetent que altres dispositius puguin repetir l'encaminament fins arribar al destí final. Una característica molt interessant d'aquest projecte és que ofereix aplicacions mòbils i web per interactuar amb els dispositius de la xarxa, permetent enviar missatges de forma molt senzilla.

L'estratègia d'encaminament que utilitza es basa en «inundació» (\est{flooding}), on cada dispositiu reenvia tots els missatges que rep, sempre que no sigui ell el destinetari, sense tenir en compte si ja els ha rebut o no. Aquest disseny tampoc considera la ubicació del destí final, fent que el missatge es transmeti per tota la xarxa. Aquests fets poden provocar un sobreús del canal, i un augment del consum energètic dels dispositius. 

Per intentar reduir aquest efecte, implementa un estil d'«inundació controlada». Quan un dispositiu rep un missatge, espera un temps proporcional a la relació senyal soroll (\acro{snr}) del missatge rebut abans de retransmetre, i cance\l.la l'enviament si un node realitza la transmissió abans. Així, un dispositiu més proper a l'origen (major \acro{snr}) esperarà més temps que un de llunyà i, per tant, el missatge el retransmetrà únicament el dispositiu llunyà. És cert que això redueix el nombre de transmissions que realitza cada dispositiu, però no evita que el missatge es retransmeti per tota la xarxa. 

Un altre inconvenient és que, a causa que els dispositius no saben quan altres dispositius realitzaran una transmissió, hagin d'estar sempre actius i en mode de recepció. Això provoca que el consum energètic dels dispositius sigui elevat (de l'ordre dels \SI{10}{\milli\watt}), fent-los poc adequats per aplicacions de monitoratge.

Durant el desenvolupament d'aquest treball, Meshtastic ha iniciat la implementació d'un protocol d'encaminament per a missatges entre dos únics dispositius. La idea d'aquest protocol és descobrir la ruta més òptima entre dos dispositius utilitzant el mecanisme d'«inundació controlada»; un cop el destí rep el missatge, respon amb un nou missatge amb la informació de la ruta, que conté tots els dispositius que han de retransmetre el missatge per arribar fins a ell. En el procés de fer arribar aquesta resposta al transmissor del missatge, tots els nodes intermedis poden generar la seva taula de rutes. En les següents transmissions, si es coneix la ruta, els missatges els reenvien únicament els nodes de la ruta. Els detalls de la implementació i funcionament d'aquest protocol es poden consultar a \cite{open_source_mesh_nodate}.

\section{LoRaMesher}
Es tracta d'una llibreria que implementa un protocol d'encaminament per a ser utilitzat en xarxes basades en LoRa. 

Cada dispositiu consta d'una taula d'encaminament, on es defineixen quin és el següent dispositiu a qui han d'enviar un missatge per fer-lo arribar al destí final. De forma periòdica, cada node transmet informació sobre la seva taula d'encaminament; els nodes que es troben a l'abast reben el missatge i actualitzen la seva taula d'encaminament amb la informació rebuda, no només coneixent informació sobre els seus veïns directes, sinó també sobre els veïns dels seus veïns, i així successivament. Es poden consultar els detalls d'aquesta implementació a \cite{sole_implementation_2022}.

Aquesta solució resol el problema de la «inundació controlada» presentat anteriorment, ja que únicament els nodes que es troben a la ruta reenvien el missatge. Malgrat això, presenta un dels inconvenients vists prèviament: tots els dispositius han d'estar sempre actius i en mode de recepció. Com s'ha mencionat, això provoca un consum elevat, reduint la viabilitat d'ús en aplicacions de monitoratge.

\chapter{Desenvolupament del protocol de comunicació}
En aquest capítol es presenta el disseny i implementació del protocol de comunicació. S'ha dissenyat amb l'objectiu de ser flexible, eficient, aplicable a una àmpla varietat de xarxes LoRa, i amb compatibilitat amb xarxes LoRaWAN. 

En un primer moment es fa un anàlisi de les característiques del protocol, així com la seva estructura. A continuació, es descriu l'entorn de desenvolupament i llibreries utilitzades. Seguidament, es presenta el disseny per capes del protocol, seguint l'estructura vista a la \autoref{sec:protocols}. Finalment, es mostra la implementació del protocol en un dispositiu real, i les verificacions realitzades per validar el funcionament.

No es farà especial menció a la implementació específica en codi de cada funcionalitat, si no que més bé es detallaran els criteris de disseny adoptats i les decisions preses. Es considera que, amb un disseny ben definit, la implementació del protocol és una tasca trivial. Malgrat això, es pot consultar la total del codi a \url{https://github.com/pfs26/Encaminament-LoRa/tree/main/firmware}.

\section{Característiques}
El disseny del protocol està fortament influenciat pel model \acro{tcp/ip}, presentat a la \autoref{sec:protocols}. El protocol presentat es basa en una pila de protocols, on cada capa s'encarrega d'una part específica del procés de comunicació. Això permet un disseny modular, i la possibilitat de modificar les funcionalitats d'una capa sense afectar la resta.

Es basa en una xarxa de dispositius estàtics, una característica habitual en sistemes de monitoratge. Aquest fet permet prescindir de mecanismes d'encaminament dinàmic, com els presentats a la \autoref{sec:treballs_relacionats}, ja que la xarxa no canvia amb el temps, permetent simplificar el protocol. Per altra banda, això implica que la topologia de la xarxa ha de ser dissenyada abans de la seva implementació, definint les taules d'encaminament de cada dispositiu.

En utilitzar la modulació LoRa, que com s'ha dit anteriorment utilitza freqüències \acro{ism}, intenta maximitzar l'eficiència d'ús del canal. Això redueix la generació d'interferències amb altres dispositius que utilitzin el mateix canal, el nombre de retransmissions, i un menor consum energètic.

Ofereix compatibilitat amb LoRaWAN, permetent que dispositius amb connexió a \est{gateways} puguin alternar entre l'ús del protocol dissenyat o LoRaWAN. Això ofereix la possibilitat a dispositius que no tenen connexió directe a \est{gateways} de comunicar-s'hi a través de dispositius que sí que en tenen. 

Finalment, el protocol incorpora mecanismes per tal d'assegurar la correcta transmissió dels missatges a través de retransmissions automàtiques i reconeixements de missatges, semblants al protocol \acro{tcp}.

S'ha pensat per tal que totes les funcionalitats siguin configurables, permetent adaptar el protocol a les necessitats de cada aplicació. Això inclou la possibilitat d'activar o desactivar la retransmissió automàtica, així com la configuració dels paràmetres de LoRa, o intervals de temps entre retransmissions.

\section{Arquitectura del codi i comunicació entre capes}
El codi s'ha intentat organitzar de forma modular, amb la intenció de facilitar-ne la seva comprensió, manteniment, i millora, implementant cada capa del protocol com un mòdul independent. Això permet que cada capa pugui ser modificada o substituïda sense afectar la resta del protocol, facilitant la seva extensió i adaptació a diferents necessitats.

El codi es divideix en dues seccions: els fitxers de capçalera (\est{headers}) i els fitxers de codi (\est{.cpp}). Els primers contenen la definició de les funcions (consultable a la ruta \fitx{firmware/include}), mentre que els segons contenen la implementació d'aquestes funcions (\fitx{firmware/src}).

En els microcontroladors, el codi s'executa de forma cíclica, amb un bucle principal que s'executa de forma contínua. Un gran inconvenient és que no permet realitzar múltiples tasques en para\l.lel, una característica important, ja que cada capa podria haver de realitzar funcions diferents al mateix temps. Per tal d'aconseguir-ho, s'ha implementat un gestor de tasques, el qual permet executar tasques de forma periòdica, després d'un cert temps, o tan bon punt sigui possible. Malgrat no permetre l'execució para\l.lela real, aquesta solució permet simular-ho.
Amb aquesta solució, tota l'execució del protocol es realitza a través de tasques generades amb el gestor, i en el bucle principal únicament s'executa el gestor de tasques, que verifica en cada cicle l'estat de cada tasca, executant les que ho requereixen (\fitx{src/utils/scheduler.cpp}).

S'ha establert que la comunicació entre capes es realitzi a través de \est{callbacks}. Així, cada capa ofereix mètodes per permetre a una altra capa configurar una funció que s'executarà quan es produeixi un esdeveniment. Per exemple, la capa d'encaminament pot configurar una funció a la capa d'accés al medi per tal que s'executi quan es rebi un missatge. Aquesta implementació ofereix més flexibilitat, i no requereix que les capes coneguin la implementació de les altres.

Finalment, per facilitar la configuració de tot el protocol, s'ha definit un únic fitxer de configuració (\fitx{config.h}), on es poden configurar tots els paràmetres del protocol, evitant-ne la seva dispersió en diverses parts del codi.

\section{Biblioteques i entorn de desenvolupament}
Per realitzar el desenvolupament, s'han utilitzat dues llibreries externes:
\begin{itemize}
    \item \est{RadioLib}. Una llibreria que permet la comunicació sense fils a través de múltiples protocols i modulacions, incloent LoRa i LoRaWAN. Aquesta llibreria s'ha utilitzat per implementar la capa física del protocol a través de LoRa, i per comunicar-se amb \est{gateways} a través de LoRaWAN. La seva documentació es pot consultar a \cite{jan_gromes_radiolib_nodate}. 
    \item \est{TaskScheduler}. Permet la creació de tasques periòdiques, amb prioritats, o amb retard inicial, així com la seva gestió. Aquesta llibreria s'ha utilitzat per implementar el gestor de tasques, que ofereix una interfície més simple i centralitzada de la llibreria. La seva documentació es pot consultar a \cite{arkhipenko_taskscheduler_nodate}.
\end{itemize}

\section{Disseny per capes}
Com en la majoria de protocols moderns, s'ha dissenyat seguint un model per capes. L'estructura es basa en el model \acro{tcp/ip}, amb la diferència de la capa física, que el model \acro{tcp/ip} no contempla de forma explícita. 
A continuació es descriuen les diferents capes del protocol, des de la capa física fins a la capa d’aplicació, indicant-ne les funcions principals, i les decisions de disseny adoptades per optimitzar el rendiment i la simplicitat del sistema.

A la \autoref{fig:diagrama_protocols} es pot observar, de forma introductòria, com s'estructura el protocol amb les diverses capes, les quals s'explicaran amb més detall en els seus respectius apartats. 
\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{imatges/capesprotocol.drawio.pdf}
    \caption{Estructura per capes del protocol}
    \label{fig:diagrama_protocols}
\end{figure}

\subsection{Capa física}
La capa física és l'encarregada de transmetre la informació proporcionada per la capa superior a través del medi físic, en aquest cas, LoRa. Tot i no ser una capa que s'implementa directament en el protocol, ja que això ho realitza el transductor LoRa, s'ha considerat oportú incloure-la per una única raó: un dispositiu amb connexió amb un \est{gateway} (es considerarà «amb capacitats LoRaWAN») pot utilitzar el transductor a través de dues interfícies diferents, el protocol definit i LoRaWAN.

A causa de l'existència d'aquestes dues interfícies, és important que existeixi un mecanisme de sincronització entre les dues. En cas contrari, es podria voler realitzar una transmissió a través de LoRa quan el transductor està configurat per a LoRaWAN, o viceversa, fent que la transmissió sigui errònia.

La seva implementació és senzilla, exposant únicament dues interfícies que permeten configurar el transductor en mode LoRa o LoRaWAN, i dues més que permeten inicialitzar o deinicialitzar el transductor. La implementació es pot consultar a \fitx{lora.cpp}. 

\subsubsection{Abstracció LoRa}
Per respectar l'estructura per capes i el model de \est{callbacks} establert, s'ha dissenyat una abstracció de la llibreria RadioLib per comunicar-se entre dispositius a través de LoRa, sense utilitzar LoRaWAN.

Fent això s'obté una interfície senzilla i ben definida per a la capa superior. A més, ofereix la possibilitat de modificar el transductor utilitzat sense afectar la resta del protocol. 

La part més complexa és l'abstracció de la recepció de missatges: una recepció es pot produir en qualsevol moment, i no es pot controlar quan es realitzarà. La llibreria RadioLib ofereix la possibilitat de configurar interrupcions, fent que quan es rep un missatge es generi una interrupció en el microcontrolador. L'inconvenient de les interrupcions és que han de realitzar tasques ràpides i senzilles, per tal de no bloquejar el fil d'execució principal (si no podrien, per exemple, interrompre una transmissió en curs). La solució emprada és que la interrupció únicament guarda en un \est{flag} que s'ha produït una recepció. El fil principal, que s'executa de forma periòdica, comprova aquest \est{flag} per saber si s'ha produït una recepció i, en cas afirmatiu, l'obté i la processa. Realment, aquesta comprovació la realitza una tasca del gestor de tasques, amb un interval configurable. Es pot llegir més sobre aquest a la \autoref{sec:altres_serveis}.

Pel que fa a les transmissions a través de LoRa, aquestes s'han hagut de dissenyar de forma bloquejant. Això implica que, quan s'utilitza la interfície de transmissió, el fil d'execució queda bloquejat fins que la transmissió s'ha completat (ja sigui correcta o incorrectament). En un primer moment es va provar de fer-ho de forma no bloquejant, fent que el transductor notifiqués quan la transmissió havia finalitzat a través d'una interrupció. A causa del fet que el transductor escollit (\acro{sx1262}) únicament permet configurar una interrupció, es va decidir que la millor solució era fer-ho de forma bloquejant, i configurar la interrupció per a la recepció de missatges, la qual no es pot controlar.

Altres mètodes que exposa la interfície permeten conèixer l'estat del canal ---si està ocupat o no---, així com establir els paràmetres de LoRa (com ara \acro{sf} o \acro{bw}) o configurar el \est{callback} de recepció. La implementació completa es pot consultar a \fitx{loraraw.cpp}.

\subsection{Accés al medi}
La funció d'aquesta capa és la gestió de l'accés al medi físic, i la comunicació entre dispositius de forma directa; és a dir, que no han d'utilitzar dispositius intermedis per comunicar-se. Un bon disseny d'aquesta capa és fonamental per garantir un ús eficient del canal, evitar interferències entre dispositius, i reduir el consum energètic. A més, és l'encarregada d'intentar garantir la integritat de les dades; és a dir, que arribin correctament al seu destí, i que les dades rebudes siguin iguals a les enviades, que no s'hagin produit errors. 

Aquesta capa es comunica amb la capa d'abstracció LoRa, rebent notificacions de recepció a través de \est{callback}, i utilitzant les seves interfícies.

\subsubsection{Estructura de les trames}
% « »
Una tasca important en qualsevol protocol és definir la forma de les dades, la «sintaxi». Així, es defineix els camps que contindrà cada missatge, i la seva longitud i posició. Per facilitat, s'ha decidit anomenar «trama» als missatges enviats per la capa d'accés al medi, sent aquest el mateix nom que s'utilitza en el model \acro{tcp/ip}.

Dos camps essencials són el \emph{receptor} i l'\emph{emissor}, que indiquen respectivament les adreces del dispositiu que rep i envia el missatge. S'ha decidit utilitzar adreces d'\SI{1}{\byte}, oferint un total de 256 adreces diferents. Malgrat això, únicament 253 són utilitzables, reservant l'adreça \fitx{0x01} per representar el \est{gateway}, la \fitx{0xFF} per un possible ús de difusió (\emph{broadcast}), i la \fitx{0x00}, per indicar l'abscència d'adreça. Aquesta quantitat de dispositius es considera suficient per a la majoria d'aplicacions de monitoratge, evitant l'ús innecessari de dades i, per tant, minimitzant el temps de transmissió i el consum energètic.

Per tal de poder identificar cada trama, s'ha inclòs un camp d'\emph{identificador} (\emph{id}), que conté un número aleatori generat per l'emissor. Aquest camp permet que el receptor pugui identificar trames duplicades i no processar-les de nou. S'ha considerat utilitzar una longitud de \SI{2}{\byte}, permetent 65536 identificadors diferents. Tot i això, s'ha reservat l'identificador \fitx{0x0000}; la utilitat d'aquest s'exposarà al \autoref{subsubsec:mac_lorawan}. En el pitjor dels casos, si 252 dispositius transmetessin a un mateix receptor, la probabilitat d'una co\l.lisió és, aproximadament, d'un 38\%. Es tracta d'un problema similar al del «problema dels aniversaris» \cite{noauthor_birthday_2025}.

Tot i semblar una probabilitat molt elevada, no es considera un fet greu: es tracta del pitjor dels casos, on 252 dispositius transmeten al mateix destí, i on el receptor recorda tots els identificadors rebuts. En aplicacions reals, la quantitat d'identificadors guardats és limitada (per exemple als últims 10), reduint la probabilitat de co\l.lisió. Si ho repetim en un cas més realista, on hi ha un receptor comú i 5 transmissors, obtenim una probabilitat de col\l.lisió del 0.015\%, i del 0.068\% si considerem 10 transmissors. Així, s'ha considerant escaient una longitud de \SI{2}{\byte}, buscant minimitzar el consum energètic i el temps de transmissió, sense afectar greument el funcionament.
% TODO: LA FINESTRA DE RECEPCIÓ HAURIA DE GUARDAR ELS IDS JUSTOS ENTRE RETRANSMISSIONS (COSA RAPIDA A MAC)

Un altre camp important és el dels \est{flags}, que conté informació sobre el missatge. En concret, s'ha definit un camp de \SI{1}{\byte} amb els següents bits:
\begin{itemize}
    \item \emph{ACK}. Té la longitud d'un únic bit. Indica si el missatge es tracta d'un reconeixement. Si està actiu, significa que el receptor ha rebut les dades correctament, i envia aquesta informació al transmissor. En cas contrari, el missatge es considera un missatge de dades.
    \item \emph{Retry}. Té la longitud de dos bits, i indica el nombre de reintent de transmissió actual. Així, si té un valor de zero, significa que és la primera transmissió. S'ha considerat que una longitud de dos bits és suficient, permetent un màxim de quatre reintents. Es pot llegir més informació al \autoref{subsubsec:integritat}.
    \item \emph{Reservats}. Els cinc bits restants s'han reservat per a un possible ús futur. En el disseny actual no s'ha definit cap funcionalitat, però s'ha considerat oportú reservar-los per tal de poder afegir noves funcionalitats sense haver de modificar l'estructura de la trama.
\end{itemize}

També s'ha inclòs un camp de \emph{longitud}, que indica la longitud de les dades del missatge. Això permet al receptor saber quants bytes ha de llegir, i evitar llegir més bytes dels necessaris. Tenint en compte que la mida màxima d'un missatge LoRa és de \SI{255}{\byte}, podem utilitzar un únic byte per codificar la longitud.

Seguidament, es troba el camp de \emph{dades}, que conté la informació a transmetre. La seva longitud és variable, i depèn del valor del camp de longitud. A causa de la longitud màxima d'un missatge LoRa de \SI{255}{\byte}, la longitud màxima de les dades d'aquesta capa serà de \SI{248}{\byte}, sent els \SI{7}{\byte} restants per a la resta de camps. 

Per acabar, al final de la trama s'ha inclòs un camp de \acro{crc}, per intentar assegurar la integritat de les dades. S'ha optat per utilitzar un \acro{crc} de \SI{1}{\byte}, ja que la quantitat de dades que es transmeten és reduïda. De nou, saquesta decisió intenta reduir la mida del missatge final. S'ha decidit ubicar-lo al final de la trama, facilitant la tasca de càlcul i verificació: cal iterar de forma lineal la trama, sense necessitat de fer salts en memòria. A la \autoref{fig:trama_mac} es pot veure un diagrama amb l'estructura de la trama.

\begin{figure}
    \centering
    \begin{bytefield}[bitwidth=1.2em]{16}
        \bitheader{0,7,8,15} \\
        \bitbox{8}{Emissor} & \bitbox{8}{Receptor} \\
        \bitbox{16}{Identificador} \\
        \bitbox{5}{\tiny Reservats} & \bitbox{2}{\tiny Retry} & \bitbox{1}{\rotatebox{90}{\tiny ACK}} & \bitbox{8}{Longitud}\\
        \wordbox[lr]{2}{Data \tiny {(màx. \SI{248}{\byte})}} \\
        \bitbox[lrb]{8}{} & \bitbox{8}{CRC}
    \end{bytefield}
    \caption{Estructura de la trama de la capa d'accés al medi.}
    \label{fig:trama_mac}
\end{figure}
\subsubsection{Transmissió}
% « »
Quan un dispositiu vol transmetre un missatge, és primordial que no interrompi una transmissió en curs. En cas contrari, es podria produir una interferència entre ambdues transmissions, provocant que cap dels missatges arribi al seu destí. 

Per tal d’evitar co\l.lisions en l’accés al canal, es pot utilitzar una estratègia \acro{csma} (\est{Carrier Sense Multiple Access}), que consisteix a verificar si el canal està lliure abans d’iniciar una transmissió. Molts transductors LoRa incorporen la funcionalitat \acro{cad} (\est{Channel Activity Detection}), que permet detectar preàmbuls d'altres transmissions. En alguns transductors, com l'utilitzat en aquest treball, \acro{sx1262}, aquesta detecció es veu millorada, ja que també permet identificar dades del paquet LoRa, i no únicament el seu preambul, fent el procés més eficaç.

Mitjançant aquesta funcionalitat, el dispositiu comprova, a través de la interfície proporcionada per la capa d'abstracció LoRa, si hi ha una transmissió en curs. Si el canal està lliure, s'inicia la transmissió, proporcionant el missatge a la capa inferior; en cas contrari, s'aplica un mecanisme d'espera aleatori conegut com a \est{Binary Exponential Backoff} (\acro{beb}). Aquest consisteix a esperar un temps aleatori que depèn del nombre de reintents d'accés previs, multiplicant per dos el temps màxim d'espera per cada intent. Així, el rang de possibles valors ve donat per l'expressió $[0, 2^r-1]\cdot K$, on ${r}$ és el nombre de reintents realitzats, i ${K}$ una constant de temps, coneguda com a  «temps d'\est{slot}». Per exemple, si és el segon reintent d'accés al canal, i la constant és de \SI{100}{\milli\second}, el rang de temps d'espera és $[0, 2^2-1]\cdot100=[0, 300]\cdot K$ mi\l.lisegons. 

El principal avantatge d'aplicar \acro{beb} és que distribueix en el temps els reintents d'accés al canal. Això redueix la probabilitat que dos dispositius que volien accedir al canal ho reintentin en el mateix moment. Si s'utilitzés un temps d'espera constant, o que incrementés de forma lineal, es produirien co\l.lisions recurrents entre dispositius, ja que es podrien sincronitzar els temps d'accés. A més, gràcies a augmentar el possible temps d'espera exponencialment, aconseguim un mecanisme que s'adapta a l'estat del canal: en moments de molt trànsit, es distribueixen molt els temps; en canals poc ocupats, el temps d'espera és reduït.
\subsubsection{Integritat}
\label{subsubsec:integritat}
% Parlar que lora incorpora CRC. S'inclou per tal que sempre s'utilitzi CRC, fins i tot si s'utilitza lora sense CRC.
% Parlar sobre ACK
Per tal d'assegurar la correcta transmissió del missatge, s'ha implementat un mecanisme de reconeixement (\est{Acknowledgment}, \acro{ack}). Després de realitzar una transmissió, el transmissor espera rebre un missatge de reconeixement del receptor, indicant que ha rebut les dades correctament i sense errors. Si no es rep el missatge de reconeixement després d'un temps d'espera, el transmissor reintenta de nou la transmissió, incrementant el valor del camp de reintents de la trama.

El temps d'espera de recepció de l'\acro{ack} es determina a través de l'expressió $3 \cdot k \cdot t_{tx}$, on $t_{tx}$ és el temps de transmissió (també conegut com a \est{airtime}) del missatge, i $k$ és un factor constant major o igual a 1. Així, el temps d'espera serà, com a mínim, de tres vegades el temps de transmissió, permetent que el receptor tingui temps de rebre el missatge enviat (requerint un temps de recepció igual al de transmissió), enviar el missatge de reconeixement, i que el transmissor original tingui temps de rebre'l. El factor ${k}$ permet ajustar el marge que es vol deixar, per exemple per si el receptor no pot enviar el missatge de reconeixement immediatament; per exemple, si $k=2$, el temps d'espera seria el doble del necessari. És important mencionar que el temps de transmissió es pot determinar prèviament, coneixent l'ample de banda, el factor d'espargiment i la longitud del missatge.

Una característica dels missatges de reconeixement és que l'identificador no és aleatori, sinó que és el mateix que el missatge que reconeix, l'«original». Això permet que el transmissor pugui identificar correctament l'\acro{ack}, i sapiga a quines dades fa referència. Si no fos així, el transmissor podria rebre un reconeixement d'una transmissió que havia considerat fallida, després d'haver-ne realitzat una altra; com que no sabria que fa referència a la primera, pensaria que la segona s'ha realitzat correctament. A més, el camp d'\acro{ack} dels \est{flags} està actiu, i el camp de dades no conté informació.

Pel que fa al nombre màxim de retransmissions, s'ha considerat oportú limitar-les a un màxim de tres, permetent així fins a quatre transmissions. Aquest criteri s'ha establert considerant que cada retransmissió incrementa el consum energètic, i la utilització del canal. Si després de quatre transmissions no s'ha pogut realitzar correctament la transmissió, és molt probable que les causes no siguin degudes a interferències, sinó a un error en el receptor o transmissor. En aquest cas, es considera millor cance\l.lar la transmissió i no gastar més energia.

Un altre mecanisme implementat per millorar la possibilitat d'èxit de la transmissió és l'increment automàtic de la potència de transmissió. En la primera transmissió s'utilitza la potència mínima, i per cada reintent, s'incrementa de forma lineal fins a la potència màxima. Ambdós valors de potència són configurables, permetent ajustar-se a les necessitats i regulacions locals de cada aplicació. Es va considerar també la possibilitat d'incrementar el factor d'espargiment (\acro{sf}), augmentant l'abast, seguint una estratègia similar a l'\acro{adr}. Malgrat això, no és una opció viable, ja que si el transmissor modifica aquest factor, el receptor no el podrà rebre correctament, ja que no coneix el nou factor (en LoRaWAN el \est{gateway} és capaç de rebre utilitzant múltiples \acro{sf}, fent aquesta solució factible). 

S'ha inclòs el mecanisme de detecció d'errors \acro{crc}, d'un byte de longitud. Aquest permet afegir redundància a les dades (d'\SI{1}{\byte} en aquest cas), calculat en el moment de la transmissió. Quan el receptor rep el missatge, calcula de nou el \acro{crc}, i el compara amb el rebut: si coincideixen, significa que el missatge ha arribat correctament, i s'envia el missatge de reconeixement. En cas contrari, el receptor ignora el missatge rebut, i no envia cap missatge de reconeixement. Això provoca que el transmissor reintenti la transmissió, amb el mecanisme vist anteriorment. Cal tenir en compte, però, que cap mecanisme de detecció d'errors és infalible, i pot donar falsos positius.  

Tot i que LoRa ofereix la possibilitat d'incorporar un \acro{crc}, s'ha decidit implementar un \acro{crc} propi, per tal de garantir que sempre s'utilitzi, independentment de la configuració dels transductor LoRa, millorant la integritat de les dades. 

Finalment, per evitar processar missatges duplicats, el receptor guarda en una cua els identificadors de les trames destinades a ell i que no contenen errors. Si rep un missatge amb un identificador que ja havia rebut, atura el processament de la trama, i únicament envia el missatge de reconeixement. La mida de la cua és configurable, però s'hauria de considerar el nombre màxim de reintents i el temps d'espera de recepció de reconeixement: si és massa petita, una retransmissió d'una trama ja rebuda es podria considerar un missatge nou, ja que el nombre d'altres trames vàlides rebudes entre ambdues transmissions és podria ser major a la capacitat de la cua; si és molt gran, es podrien produïr co\l.lisions d'identificadors, on dos missatges vàlids diferents tenen el mateix identificador i, com que el receptor encara recorda el primer, considera el segon com a duplicat. 
\subsubsection{Recepció}
% « »
La recepció de trames es realitza mitjançant el \est{callback} de la capa d'abstracció LoRa. En rebre una trama, es verifica el \acro{crc}; si no és correcte, s'ignora el missatge, ja que no podem assegurar que cap de les dades rebudes sigui correcta.

Seguidament es verifica si el dispositiu és el destinetari de la trama. Si no ho és, no és necessari continuar; en cas afirmatiu, es determina si la trama és de reconeixement, comprovant el bit d'\acro{ack} dels \est{flags}, i comparant l'identificador de la trama rebuda amb el de l'enviada. Si no s'havia realitzat cap transmissió prèvia, el missatge es considera un error, i s'ignora. En cas contrari, es considera que la transmissió ha estat correcta, i es notifica a la capa superior a través d'un \est{callback}. Si el missatge rebut no és un missatge de reconeixement, es guarda l'identificador a la cua de trames rebudes, i es notifica a la capa superior a través d'un \est{callback}.

S'exposa una interfície que permet a la capa superior obtenir les dades de la trama rebuda, la qual únicament s'hauria d'utilitzar després que s'hagi notificat a través de l'anterior \est{callback}. En cas contrari, les dades que s'obtinguin podrien ser incorrectes o duplicades.
\subsubsection{Cues de transmissió i recepció}
% « »
Sense la implementació d'una cua de transmissió, després d'iniciar un enviament, no seria possible realitzar-ne cap altre fins que aquest finalitzés, ja sigui per la recepció d’un \acro{ack} o per esgotament dels reintents. Això faria que la interfície de transmissió exposada a la capa superior quedés bloquejada. En conseqüència, si una capa superior volgués iniciar una nova transmissió, també hauria de quedar-se bloquejada, propagant el bloqueig cap amunt, o bé descartar l’enviament.

Per evitar-ho, s'ha implementat una cua de transmissió. Quan es vol realitzar un nou enviament, es comprova si n'hi ha una en curs: si és així, s'afegeix la trama a la cua de transmissió; en cas contrari, s'inicia directament l'enviament. Un cop finalitzada una transmissió, es comprova si hi ha més trames a la cua i, si n'hi ha, s'inicia el seu enviament.

Un aspecte important d’aquesta cua és la gestió dels reconeixements. Si un \acro{ack} es trametés a través de la cua, caldria esperar a transmetre totes les trames anteriors, fet que podria retardar excessivament el seu enviament. Això podria provocar que el transmissor considerés que la transmissió havia fallat. Per evitar-ho, els missatges de reconeixement s’envien de manera immediata, sense passar per la cua, minimitzant així el temps de resposta.

Pel que fa a la recepció, també s’ha implementat una cua. Un cop processada una trama rebuda, explicat anteriorment, aquesta es guarda a la cua i es notifica la seva arribada a la capa superior. S’hi exposen dues interfícies: una permet conèixer el nombre de trames emmagatzemades, i l’altra, obtenir les dades de la primera trama. Aquesta implementació proporciona més flexibilitat a la capa superior per gestionar els missatges rebuts, evitant el risc de sobrescriure dades rebudes prèviament.

La implementació de la cua de transmissió introdueix un problema: en notificar a la capa superior que s'ha transmès un missatge, aquesta no coneix quin missatge s'ha enviat. Per solucionar-ho, quan la capa superior inicia una transmissió, se li retorna l'identificador de la trama. Un cop s'ha enviat, el \est{callback} de fi de transmissió rep com a paràmetre l'identificador de la trama, permetent així a la capa superior saber quin missatge ha estat enviat. A més, s'afegeix un \est{callback} de transmissió errònia, que notifica a la capa superior quan no s'ha pogut realitzar una transmissió (per exemple, per esgotament de reintents), proporcionant també l'identificador de la trama.
\subsubsection{Detalls d'implementació}
La implementació d'aquesta capa s'ha realitzat mitjançant una màquina d'estats finita (\acro{fsm}). Això permet tenir un control més precís sobre l'estat de la capa, i el flux de les dades. El seu disseny, basat en les explicacions anteriors, es pot veure a la \autoref{fig:mac_fsm}.

Com la resta del protocol, s'ha implementat de forma no bloquejant ---amb l'excepció de la transmissió a través de la capa inferior, que sí que és bloquejant---, utilitzant el gestor de tasques. Aquestes s'utilitzen per programar els temps d'espera de recepció de reconeixement, i els de l'accés al canal (\acro{beb}). A més, s'han utilitzat per programar l'execució d'esdeveniments de la màquina d'estats principal. Això permet que l'execució de la \acro{fsm} no afecti altres tasques si el temps d'execució és molt llarg.

Pel que fa a la implementació de la cua, s'ha utilitzat una cua enllaçada (mitjançant una {\emph{linked list}), que permet afegir i eliminar elements de forma dinàmica, sense necessitat de conèixer prèviament la mida màxima de la cua. Aquesta implementació permet una millor gestió de la memoria, utilitzant únicament la quanitat necessària en cada moment. A més, és més eficient que una llista basada en vectors, ja que no requereix moure tots els elements quan se n'afegeix o se n'elimina un. L'única limitació és la memòria disponible del microcontrolador; de forma experimental, s'ha observat una disponibiltiat d'uns \SI{300}{\kilo\byte} en el microcontrolador ESP32-WROOM-32, que permetria emmagatzemar més de \num{3000} trames de \SI{255}{\byte} (mida màxima de la trama, comptant capçalera).

La implementació d'aquesta capa es pot trobar al fitxer \fitx{mac.cpp}, l'extensió de la capa amb funcionalitats de cua al \fitx{mac_buffer.cpp}, i la de cua enllaçada a \fitx{utils/LinkedFIFO.hpp}.
\subsubsection{LoRaWAN}
\label{subsubsec:mac_lorawan}
LoRaWAN ja defineix els mecanismes d'accés al medi i, per tant, no aplica els detalls comentats anteriorment. Malgrat això, s'ha decidit implementar una capa d'abstracció per tal de poder-la utilitzar fàcilment, i integrar-la amb l'estructura de la resta del protocol.

S'utilitzen dispositius LoRaWAN de classe A, i la definició 1.1 del protocol LoRaWAN, la qual afegeix millores de seguretat respecte les versions \acro{1.0.x} anteriors. Es pot consultar l'especificació completa a \cite{noauthor_lorawan_2023}.

Una millora de seguretat important és que no permet la reutilització de \est{nonces}, un mecanisme que permet garantir la unicitat de les connexions a la xarxa. És a dir, evita que un tercer pugui escoltar un missatge de connexió i transmetre'l de nou, fent-se passar pel transmissor original. En les versions \acro{1.0.x} s'implementava com un valor aleatori; en la versió \acro{1.1} s'implementa com un comptador que incrementa per cada unió a la xarxa, que tant dispositiu com \est{gateway} han de recordar. Si el dispositiu utilitza un \est{nonce} ja utilitzat, el servidor de la xarxa rebutjarà la connexió. 

Aquesta millora implica la utilització de memòria no volàtil en el dispositiu, per tal de poder guardar el valor del comptador fins i tot després de reiniciar-se. Gràcies a la capa d'abstracció, la implementació d'aquest mecanisme és trivial: quan la capa superior utilitza la interfície exposada per iniciar la connexió, la capa LoRaWAN inicia la connexió, i guarda el \est{nonce} a la memòria no volàtil.

A causa de la possibilitat d'utilitzar LoRa o LoRaWAN, si després d'utilitzar LoRaWAN es canvia al mode LoRa, una següent connexió a LoRaWAN implicaria un nou procés d'inici de connexió, que pot ser lent. Per evitar-ho, després de cada transmissió es guarden els valors de sessió, que contenen comptadors d'\est{uplinks} i \est{downlinks}, i claus per encriptar els missatges, generades en unir-se a la xarxa. Els valors de sessió no s'emmagatzemen a memòria no volàtil i, per tant, després de reiniciar-se es forçarà una nova unió a la xarxa. Així, el que s'aconsegueix guardant la sessió és que els canvis entre LoRa i LoRaWAN siguin molt més ràpids, no requerint un nou procés d'unió, però sense perdre la seguretat de LoRaWAN, requerint noves unions després de reiniciar-se (com si fos un dispositiu que únicament implementa LoRaWAN).

En utilitzar dispositius de classe A, la recepció es produeix únicament després d'una transmissió. Això implica que, si una capa superior utilitza la interfície per enviar un missatge a través de LoRaWAN, aquesta també hauria de retornar les possibles dades rebudes. Aquest comportament és totalment diferent a l'establert en la resta de capes, on la capa inferior notifica a través de \est{callbacks}. Per solucionar-ho, es simula aquest comportament, i si després de realitzar una transmissió s'ha rebut un missatge, es programa una tasca ---a través del gestor de tasques--- que executarà el \est{callback} de recepció de la capa superior tan aviat com sigui possible. 

Com que LoRaWAN no utilitza el protocol d'accés al medi exposat anteriorment, l'identificador que s'assigna a les transmissions és el \fitx{0x0000}. Utilitzar sempre aquest identificador és segur, ja que com que no utilitza el protocol d'accés al medi exposat, tampoc implementa cues, i les transmissions són bloquejants, fent que no hi pugui haver dues transmissions amb el mateix identificador a la vegada. A més, cal recordar que s'havia reservat aquest identificador i, per tant, no serà mai assignat pel protocol d'accés al medi a cap trama.

Es pot consultar la implementació d'aquesta capa al fitxer \fitx{lorawan.cpp}.
\subsubsection{Situacions especials}
En aquest subapartat es descriuen diferents situacions que poden produir-se durant l'ús del protocol de transmissió, juntament amb el comportament esperat del sistema en cada cas. Conèixer aquestes situacions teòriques permet determinar si es comporta de forma adequada en situacions reals.
% \\
% \\

A la \autoref{fig:mac_tx_correcte_reintent} s'observa un exemple de transmissió correcta, amb una següent transmissió també satisfactòria després d'un reintent. Es tractaria d'una situació considerada comú, i on l'estat final dels dos dispositius és l'esperat: el dispositiu 1 realitza 2 transmissions que considera satisfactòries (ja que rep \acro{ack}), i el dispositiu 2 les ha rebut correctament.
% TX correcta + TX amb 1 reintent (no rep dades)
\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        device/.style={draw=none, minimum width=1cm, minimum height=0.8cm},
        msg/.style={-Stealth, thick},
        ack/.style={-Stealth, thick, dashed},
        timeout/.style={red, thick, dashed},
        node distance=1cm and 3cm,
        timeline/.style={draw, dashed, white},
        fail/.style={thick, cross at end}
    ]
    
    % Devices
    \node[device] (dev1) at (0,0) {Dispositiu 1};
    \node[device, right=of dev1] (dev2) {Dispositiu 2};
    % \draw[msg] ($dev1.south$) -- ($(dev1.south)+(0,-3)$);
    \draw ($(dev1.south) + (0,0)$) -- ($(dev1.south) + (0,-5)$);
    \draw ($(dev2.south) + (0,0)$) -- ($(dev2.south) + (0,-5)$);
    
    % First message
    \draw[msg] ($(dev1.south)+(0,-0.5)$) -- ($(dev2.south)+(0,-1.0)$) node[midway, above] {\tiny{Trama 1}};
    \draw[ack] ($(dev2.south)+(0,-1.0)$) -- ($(dev1.south)+(0,-1.5)$) node[midway, below] {\tiny{\acro{ack} 1}};
    \draw[timeout] ($(dev1.south)+(0,-2)$) -- ++(-0.5,0) node[left] {\small{\acro{tout ack 1}}};
    \node[right] at ($(dev2.south)+(0,-0.5)$) {\tiny{D1. Inici transmissió trama 1}};
    \node[right] at ($(dev2.south)+(0,-0.9)$) {\tiny{D2. Recepció trama 1. Notifica capa superior}};
    \node[right] at ($(dev2.south)+(0,-1.1)$) {\tiny{\hspace{2em}Transmet \acro{ack}}};
    \node[right] at ($(dev2.south)+(0,-1.4)$) {\tiny{D1. Recepció \acro{ack}. Fi transmissió}};
    \node[right] at ($(dev2.south)+(0,-1.6)$) {\tiny{\hspace{2em}Notifica capa superior}};

    
    % Second message (fails)
    % \draw[fail] ($(dev1.south)+(0,-2.5)$) -- ($(dev2.south)+(0,-3)$) node[midway, above] {\tiny{Trama 2}};
    \draw[fail] ($(dev1.south)+(0,-2.5)$) -- ($ (dev1.south) !0.5! (dev2.south) + (0,-2.75) - (0,0) $) node[midway, above] {\tiny{Trama 2}};
    \draw[timeout] ($(dev1.south)+(0,-4)$) -- ++(-0.5,0) node[left] {\small{\acro{tout ack} 2}};
    \node[right] at ($(dev2.south)+(0,-2.5)$) {\tiny{D1. Inici transmissió trama 2}};
    
    % Retransmit message
    \draw[msg] ($(dev1.south)+(0,-4)$) -- ($(dev2.south)+(0,-4.5)$) node[midway, above] {\tiny{Trama 2}};
    \draw[ack] ($(dev2.south)+(0,-4.5)$) -- ($(dev1.south)+(0,-5)$) node[midway, below] {\tiny{\acro{ack} 2}};
    \node[right] at ($(dev2.south)+(0,-4)$) {\tiny{D1. Fi espera recepció \acro{ack}. Retransmissió 1}};
    \node[right] at ($(dev2.south)+(0,-4.4)$) {\tiny{D2. Recepció trama 2. Notifica capa superior}};
    \node[right] at ($(dev2.south)+(0,-4.6)$) {\tiny{\hspace{2em}Transmet \acro{ack}}};
    \node[right] at ($(dev2.south)+(0,-4.9)$) {\tiny{D1. Recepció \acro{ack}. Fi transmissió}};
    \node[right] at ($(dev2.south)+(0,-5.1)$) {\tiny{\hspace{2em}Notifica capa superior}};

    \end{tikzpicture}
    \caption{Transmissió correcta, i segona transmissió correcta després de reintent.}
    \label{fig:mac_tx_correcte_reintent}
\end{figure}

Una situació més excepcional és la representada a la \autoref{fig:mac_tx_considerat_fallida}, on el dispositiu 1 realitza una transmissió, sense rebre en cap retransmissió el missatge de reconeixement. Malgrat això, el dispositiu 2 sí que havia rebut la trama, generant l'\acro{ack} corresponent, el qual no arriba al dispositiu 1. S'observa com en la segona recepció de la trama, el dispositiu 2 no notifica a la capa superior, ja que ja s'havia processat prèviament. En aquesta situació, el dispositiu 1 considera que la transmissió no ha estat satisfactòria, malgrat que el dispositiu 2 sí que havia rebut la trama.

% TX incorrecte + 3 reintents - Fallada transmissió
\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        node distance=1cm and 3cm,
        device/.style={draw=none, minimum width=1cm, minimum height=0.8cm},
        msg/.style={-Stealth, thick},
        ack/.style={-Stealth, thick, dashed},
        timeout/.style={red, thick, dashed},
        fail/.style={thick, cross at end},
        failAck/.style={thick, cross at end, dashed},
    ]

        % Devices
        \node[device] (dev1) at (0,0) {Dispositiu 1};
        \node[device, right=of dev1] (dev2) {Dispositiu 2};
        % \draw[msg] ($dev1.south$) -- ($(dev1.south)+(0,-3)$);
        \draw ($(dev1.south) + (0,0)$) -- ($(dev1.south) + (0,-5)$);
        \draw ($(dev2.south) + (0,0)$) -- ($(dev2.south) + (0,-5)$);

        % First message
        \draw[fail] ($(dev1.south)+(0,-0.5)$) -- ($ (dev1.south) !0.5! (dev2.south) + (0,-0.75) - (0,0) $) node[midway, above] {\tiny{Trama 1}};
        \draw[timeout] ($(dev1.south)+(0,-1.5)$) -- ++(-0.5,0) node[left] {\small{\acro{tout ack}}};
        \node[right] at ($(dev2.south)+(0,-0.5)$) {\tiny{D1. Inici transmissió trama 1}};
        
        \draw[fail] ($(dev1.south)+(0,-1.5)$) -- ($ (dev1.south) !0.5! (dev2.south) + (0,-1.75) - (0,0) $) node[midway, above] {\tiny{Trama 1}};
        \draw[timeout] ($(dev1.south)+(0,-2.5)$) -- ++(-0.5,0) node[left] {\small{\acro{tout ack}}};
        \node[right] at ($(dev2.south)+(0,-1.5)$) {\tiny{D1. Fi espera recepció \acro{ack}. Retransmissió 1}};

        \draw[msg] ($(dev1.south)+(0,-2.5)$) -- ($ (dev2.south) + (0,-3) $) node[midway, above] {\tiny{Trama 1}};
        \draw[failAck] ($(dev2.south)+(0,-3)$) -- ($(dev1.south) !0.5! (dev2.south)+(0,-3.25)$) node[midway, below] {\tiny{\acro{ack} 1}};
        \draw[timeout] ($(dev1.south)+(0,-3.5)$) -- ++(-0.5,0) node[left] {\small{\acro{tout ack}}};
        \node[right] at ($(dev2.south)+(0,-2.5)$) {\tiny{D1. Fi espera recepció \acro{ack}. Retransmissió 2}};
        \node[right] at ($(dev2.south)+(0,-2.9)$) {\tiny{D2. Recepció trama 1. Notifica capa superior}};
        \node[right] at ($(dev2.south)+(0,-3.1)$) {\tiny{\hspace{2em}Transmet \acro{ack}}};

        % \node[align=left] {\tiny{This is a\\demonstration.}};

        \draw[msg] ($(dev1.south)+(0,-3.5)$) -- ($ (dev2.south) + (0,-4) $) node[midway, above] {\tiny{Trama 1}};
        \draw[failAck] ($(dev2.south)+(0,-4)$) -- ($(dev1.south) !0.5! (dev2.south)+(0,-4.25)$) node[midway, below] {\tiny{\acro{ack} 1}};
        \draw[timeout] ($(dev1.south)+(0,-4.5)$) -- ++(-0.5,0) node[left] {\small{\acro{tout ack}}};
        \node[right] at ($(dev2.south)+(0,-3.5)$) {\tiny{D1. Fi espera recepció \acro{ack}. Retransmissió 3}};
        \node[right] at ($(dev2.south)+(0,-3.9)$) {\tiny{D2. Recepció trama 1. No notifica capa superior}};
        \node[right] at ($(dev2.south)+(0,-4.1)$) {\tiny{\hspace{2em}Transmet \acro{ack}}};

        \node[right] at ($(dev2.south)+(0,-4.5)$) {\tiny{D1. Fi espera recepció \acro{ack}. Reintents esgotats}};
        \node[right] at ($(dev2.south)+(0,-4.7)$) {\tiny{\hspace{2em}Trama 1 fallada. Notifica capa superior}};

    \end{tikzpicture}
    \caption{Transmissió considerada fallida, rebuda correctament per receptor.}
    \label{fig:mac_tx_considerat_fallida}
\end{figure}

Per acabar es mostra una situació més complexa i completa, representada a la \autoref{fig:mac_tx_complet}. Es representen tres dispositius, amb la primera transmissió del dispositiu 2 completada després d'un reintent. En el procés d'espera de recepció de reconeixement, es mostra com aquest rep una trama, enviada pel dispositiu 1, i genera el corresponent \acro{ack}. Per acabar, es representa el comportament de la cua de transmissió, on el dispositiu 2 inicia una nova transmissió just després de rebre el missatge de reconeixement.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        node distance=1cm and 3cm,
        device/.style={draw=none, minimum width=1cm, minimum height=0.8cm},
        msg/.style={-Stealth, thick},
        ack/.style={-Stealth, thick, dashed},
        timeout/.style={thick, red, dashed},
        fail/.style={thick, cross at end},
        failAck/.style={thick, cross at end, dashed},
    ]

        % Devices
        \node[device] (dev1) at (0,0) {D1};
        \node[device, right=of dev1] (dev2) {D2};
        \node[device, right=of dev2] (dev3) {D3};
        \draw ($(dev1.south) + (0,0)$) -- ($(dev1.south) + (0,-5)$);
        \draw ($(dev2.south) + (0,0)$) -- ($(dev2.south) + (0,-5)$);
        \draw ($(dev3.south) + (0,0)$) -- ($(dev3.south) + (0,-5)$);

        \draw[fail] ($(dev2.south)+(0,-0.5)$) -- ($ (dev2.south) !0.5! (dev3.south) + (0,-0.75) - (0,0) $) node[midway, above] {\tiny{Trama \fitx{0x3E8F}}};
        \draw[timeout] ($(dev2.south)+(0,-2)$) -- ++(-0.5,0) node[left] {\small{\acro{\tiny{tout}}}};
        \node[right] at ($(dev3.south)+(0,-0.5)$) {\tiny{D2. Inici transmissió trama \fitx{0x3E8F}}};

        \draw[msg] ($(dev1.south)+(0,-1)$) -- ($(dev2.south) + (0,-1.5) - (0,0) $) node[midway, above] {\tiny{Trama \fitx{0x73D1}}};
        \draw[timeout] ($(dev1.south)+(0,-2.5)$) -- ++(-0.5,0) node[left] {\small{\acro{\tiny{tout}}}};
        \node[right] at ($(dev3.south)+(0,-1)$) {\tiny{D1. Inici transmissió trama \fitx{0x73D1}}};

        \draw[ack] ($(dev2.south)+(0,-1.5)$) -- ($(dev1.south)+(0,-2)$) node[midway, above] {\tiny{\acro{ack} \fitx{0x73D1}}};
        \node[right] at ($(dev3.south)+(0,-1.4)$) {\tiny{D2. Recepció trama \fitx{0x73D1}. Notifica}};
        \node[right] at ($(dev3.south)+(0,-1.6)$) {\tiny{\hspace{2em}capa superior. Transmet \acro{ack}}};
        \node[right] at ($(dev3.south)+(0,-1.9)$) {\tiny{D1. Fi TX \fitx{0x73D1}. Notifica capa superior}};
        
        \draw[msg] ($(dev2.south)+(0,-2)$) -- ($(dev3.south) + (0,-2.5) - (0,0) $) node[midway, above] {\tiny{Trama \fitx{0x3E8F}}};
        \draw[ack] ($(dev3.south)+(0,-2.5)$) -- ($(dev2.south)+(0,-3)$) node[midway, above] {\tiny{\acro{ack} \fitx{0x3E8F}}};
        \draw[timeout] ($(dev2.south)+(0,-3.5)$) -- ++(-0.5,0) node[left] {\small{\acro{\tiny{tout}}}};
        \node[right] at ($(dev3.south)+(0,-2.1)$) {\tiny{D2. Fi espera recepció \acro{ack} \fitx{0x3E8F}. Retransmissió 1}};
        \node[right] at ($(dev3.south)+(0,-2.4)$) {\tiny{D3. Recepció trama \fitx{0x3E8F}. Notifica}};
        \node[right] at ($(dev3.south)+(0,-2.6)$) {\tiny{\hspace{2em}capa superior. Transmet \acro{ack}}};

        \draw[msg] ($(dev2.south)+(0,-3)$) -- ($(dev1.south) + (0,-3.5) - (0,0) $) node[midway, above] {\tiny{Trama \fitx{0x8EE5}}};
        \draw[ack] ($(dev1.south)+(0,-3.5)$) -- ($(dev2.south)+(0,-4)$) node[midway, above] {\tiny{\acro{ack} \fitx{0x8EE5}}};
        \draw[timeout] ($(dev2.south)+(0,-4.5)$) -- ++(-0.5,0) node[left] {\small{\acro{\tiny{tout}}}};
        \node[right] at ($(dev3.south)+(0,-2.9)$) {\tiny{D2. Fi TX \fitx{0x3E8F}. Notifica capa superior}};
        \node[right] at ($(dev3.south)+(0,-3.1)$) {\tiny{\hspace{2em}Inici TX des de cua \fitx{0x8EE5}}};
        \node[right] at ($(dev3.south)+(0,-3.4)$) {\tiny{D1. Recepció trama \fitx{0x8EE5}. Notifica}};
        \node[right] at ($(dev3.south)+(0,-3.6)$) {\tiny{\hspace{2em}capa superior. Transmet \acro{ack}}};
        \node[right] at ($(dev3.south)+(0,-4)$) {\tiny{D2. Fi TX \fitx{0x8EE5}. Notifica capa superior}};


    \end{tikzpicture}
    \caption{Transmissió considerada fallida, rebuda correctament per receptor.}
    \label{fig:mac_tx_complet}
\end{figure}

\subsection{Encaminament estàtic}
La funció d'aquesta capa és la de determinar quin és el següent dispositiu a qui s'ha d'enviar un missatge perquè arribi al destí final. Tal com s’ha comentat anteriorment, s’utilitza un encaminament estàtic, de manera que les taules que defineixen les rutes s’han de configurar prèviament. Aquesta capa també és responsable de gestionar i accedir a aquestes taules quan sigui necessari.

Una altra tasca important que duu a terme és la de commutar entre l’ús del protocol definit, a través de la capa d’accés al medi, i l’ús de LoRaWAN, mitjançant la capa d’abstracció de LoRaWAN comentada anteriorment. D’aquesta manera, la capa d’encaminament es comunica amb la capa d’accés al medi, rebent notificacions de final de transmissió i de recepció de missatges a través del protocol personalitzat, i també amb la capa d’abstracció de LoRaWAN, rebent notificacions de recepció de missatges a través de LoRaWAN.

\subsubsection{Estructura de les trames}
És necessari que aquesta capa pugui saber quin és el destí final del missatge, per tal de determinar quin és el següent dispositiu a qui s'ha d'enviar. Per tant, ha de contenir un camp amb l'adreça del dispositiu de \emph{destí}. També s'inclou l'adreça del dispositiu \emph{emissor}, permetent saber d'on s'ha originat el missatge. Ambdós camps tenen la mateixa longitud que els de la capa d’accés al medi, és a dir, \SI{1}{\byte}, la qual cosa permet reutilitzar les mateixes adreces en les dues capes i simplifica la implementació.

Per tal d'evitar transmissions infinites ---per exemple, si ruta resulta en un bucle--- s'afegeix un camp de \acro{ttl} (\est{Time To Live}), que indica el nombre màxim de salts que pot fer un missatge abans de ser descartat. Per exemple, si l'emissor genera un missatge amb un \acro{ttl} d'1, aquest només podrà ser transmès al següent dispositiu de la ruta. El camp \acro{ttl} ocupa \SI{1}{\byte}, permetent un màxim de 255 salts. Tenint en compte que la xarxa està limitada a un màxim de 253 dispositius, aquesta longitud és suficient, ja que no haurien d'existir rutes de longitud superior al màxim de dispositius.

Per acabar, s'ha inclòs un camp de \emph{longitud}, que indica la longitud de les dades del missatge. Com en el protocol d'accés al medi, permet saber quants bytes s'han de llegir per obtenir les dades. Es reserva també un byte, ja que la longitud màxima de les dades del protocol d'accés al medi és de \SI{248}{\byte}. Així, les \emph{dades} podran tenir una longitud màxima de \SI{244}{\byte}, sent els \SI{4}{\byte} restants per a la resta de camps.

Seguint el model \acro{tcp/ip}, el missatges d'aquesta capa s'anomenen \emph{paquets}. La seva estructura, amb els camps prèviament esmentats, es pot observar a la \autoref{fig:paquet_encaminament}.

\begin{figure}
    \centering
    \begin{bytefield}[bitwidth=1.2em]{16}
        \bitheader{0,7,8,15} \\
        \bitbox{8}{Origen} & \bitbox{8}{Destí} \\
        \bitbox{8}{TTL} & \bitbox{8}{Longitud} \\
        \wordbox{3}{Data \tiny {(màx. \SI{244}{\byte})}}
    \end{bytefield}
    \caption{Estructura del paquet de la capa d'encaminament estàtic.}
    \label{fig:paquet_encaminament}
\end{figure}
\subsubsection{Gestió de la taula d'encaminament}
% comentar que implementa interfície per afegir/eliminar taules, per si mai es defineix un mecanisme d'encaminament dinàmic
La taula d'encaminament és l'encarregada de definir quin és el següent dispositiu al qual s’ha d’enviar un paquet per tal que arribi al seu destí final. Per simplicitat, s’ha optat per permetre una única ruta per a cada dispositiu, establint així una relació un a un entre cada adreça de destí i el següent salt. Això limita la mida màxima de la taula d’encaminament a 254 entrades (253 dispositius i un \est{gateway}). A la \autoref{tab:taula_encaminament} es mostra un exemple de taula d'encaminament, on es pot veure que el dispositiu té comunicació directa amb els dispositius \fitx{0x4E} i \fitx{0xA1}, i si es vol enviar un paquet al \est{gateway}, aquest s’ha de fer arribar a través de \fitx{0x4E}.

\begin{table}
    \centering
    \begin{tabular}{p{3cm}<{\centering}p{3cm}<{\centering}}
        \toprule
        \textbf{Destí} & \textbf{Següent salt} \\
        \midrule
        \fitx{0x01} & \fitx{0x4E} \\
        \fitx{0x4E} & \fitx{0x4E} \\
        \fitx{0x12} & \fitx{0xA1} \\
        \fitx{0xA1} & \fitx{0xA1} \\
        \bottomrule    
    \end{tabular}
    \caption{Exemple taula d'encaminament.}
    \label{tab:taula_encaminament}
\end{table}

\begin{figure}
    \centering
    \begin{bytefield}[bitwidth=0.5em]{32}
        \bitheader{0,7,15,23,31,39} \\
        \bitbox{8}{\fitx{0x01}} & \bitbox{8}{\fitx{0x4E}} & \bitbox{8}{\fitx{0x4E}} & 
        \bitbox{8}{\fitx{0x4E}} & \bitbox{8}{\fitx{0x12}} & \bitbox{8}{\dots} 
    \end{bytefield}
    \caption{Representació emmagatzematge de la taula d'encaminament.}
    \label{fig:emmgatzematge_taula_encaminament}
\end{figure}

Una propietat important de la taula d'encaminament és que aquesta ha de ser persistent. Això vol dir que si el dispositiu es reinicia, aquest ha de poder recuperar la taula d'encaminament anteriorment configurada. En cas contrari, com que no es genera de forma dinàmica, aquesta capa quedaria inoperativa. Per evitar-ho, s'utilitza de nou la memòria no volàtil \acro{NVS}. La mida màxima de la taula serà de \SI{508}{\byte} (254 entrades, 2 adreces d'\SI{1}{\byte} per entrada), fet que no és problema en el dispositiu utilitzat (ESP32).

Per evitar fer lectures a la memòria \acro{nvs} per a cada consulta de ruta, es carrega tota la taula a la memòria volàtil en inicialitzar la capa, fent que les lectures siguin molt més ràpides. El format d’emmagatzematge consisteix en una seqüència de bytes, on cada parell representa una entrada: el primer byte indica l’adreça de destí i el segon, el següent salt. Aquest format facilita el bolcat de la taula entre memòria volàtil i no volàtil, ja que no cal fer cap conversió. A la \autoref{fig:emmgatzematge_taula_encaminament} es pot observar com s'emmagatzemaria part de la taula d'encaminament representada anteriorment. 

S’han implementat interfícies per afegir, eliminar i actualitzar entrades de la taula d’encaminament. Tot i que no són estrictament necessàries per al protocol d’encaminament estàtic, poden resultar útils si en el futur es vol implementar un encaminament dinàmic. En aquest cas, després de fer una modificació de la taula de rutes, s'actualitza la taula a la memòria \acro{nvs}, per tal de garantir la seva persistència.

La implementació s'ha fet en un mòdul independent, consultable al fitxer \fitx{routing_table.cpp}, permetent que sigui reutilitzable en altres possibles protocols d'encaminament.
\subsubsection{Transmissió}
\label{subsubsec:routing_tx}
Quan es vol realitzar una transmissió d'un paquet a un destí final, es realitza una consulta a la taula d'encaminament per determinar quin és el següent salt:
\begin{itemize}
    \item Si el següent salt és el \est{gateway}, representat amb l'adreça \fitx{0x01}, es realitza la transmissió del paquet a través de la capa d'abstracció de LoRaWAN.
    \item Si el següent salt és un altre dispositiu, es realitza la transmissió a través de la capa d'accés al medi.
\end{itemize}

Pel que fa al valor de \acro{ttl}, s'assigna el valor configurat per defecte (definit en temps de compilació), que depèn de la mida de la xarxa i de cada situació, però que cal recordar que està limitat a 255.

És important recordar que la capa d'accés al medi implementa una cua de transmissió, i que notifica a la capa d'encaminament quan la transmissió ha acabat. Per aquest motiu, la capa d'encaminament ofereix també la possibilitat de notificar a la capa superior de la finalització d'una transmissió, proporcionant de nou l'identificador. Aquestes notificacions (generades a través de \est{callback}) únicament es generaran per transmissions originades per la capa superior. És a dir, si la capa d'encaminament inicia una transmissió (per exemple, per encaminar un paquet rebut a través de la capa d'accés al medi), no es notificarà a la capa superior, ja que aquesta transmissió no s'hi ha originat. Aquest filtrat es pot realitzar guardant l'identificador de les trames transmeses (obtingut a través de la capa d'accés al medi) en una cua únicament si s'originen per la capa superior.

A més, cal també tenir en compte que la capa d'accés al medi implementa notificacions per transmissions fallides. De nou, aquesta notificació únicament es propagarà a la capa superior si el paquet s'hi havia originat, i no és una transmissió fallida d'un paquet encaminat. 

És també important recordar que les transmissions mitjançant LoRaWAN són bloquejants. Així, l'estat de la transmissió es coneix en el mateix moment en que s'inicia la transmissió a través de la capa d'abstracció. Per mantenir la coherència amb la resta de capes, s'implementen notificacions de transmissió simulades, programant les notificacions de transmissió correcta i fallida a través del gestor de tasques.
\subsubsection{Recepció}
\label{subsubsec:routing_rx}
% « »
Quan la capa d’accés al medi notifica a la capa d’encaminament la recepció d’un paquet, mitjançant el \est{callback} corresponent, aquesta rep el paquet i verifica quin és el seu destí final. Si n'és el destí final, es notifica a la capa superior perquè el processi i es dona per finalitzat el procés. En canvi, si el paquet no és per a ell, es consulta la taula d’encaminament per determinar quin és el següent salt.

Si no existeix cap entrada a la taula per a l’adreça de destí del paquet rebut, aquest es descarta. Encara que podria semblar lògic generar un missatge de «no-reconeixement» per informar l’emissor, s’ha decidit no implementar aquest mecanisme. Fer-ho implicaria assignar tasques a la capa d’encaminament, que van més enllà de determinar la ruta del paquet. A més, aquest tipus de notificació incrementaria el nombre de transmissions, fet no desitjat en un protocol de baix consum. Tampoc hauria de ser necessari si la configuració de les taules d’encaminament s'ha realitzat correctament, ja que les rutes no canvien dinàmicament.

Si el valor del \acro{ttl} del paquet rebut és 1 (i el paquet no és per ell, verificat prèviament), es descarta el paquet, ja que no pot fer més salts. En cas contrari, es decrementa el valor del \acro{ttl} i es transmet el paquet al següent salt a través de la capa d'accés al medi o de LoRaWAN, segons correspongui.

Gràcies a la capa d'abstracció de LoRaWAN, que implementa la recepció de paquets a través de notificacions per \est{callback}, no hi ha diferència entre la recepció d'un paquet a través de LoRaWAN o a través del protocol personalitzat. En ambdós casos, la capa d'encaminament rep el paquet i realitza les mateixes operacions, explicades anteriorment.

Com s'ha comentat anteriorment, la finalització de la transmissió d'aquest paquet encaminat no es notificarà a la capa superior, ja que no s'hi ha originat.
\subsubsection{Detalls d'implementació}
La implementació d’aquesta capa no s’ha basat en una màquina d’estats perquè no és necessari mantenir cap estat entre transmissions ni recepcions. En aquest cas, el comportament de la capa d’encaminament és totalment síncron, permetent basar la implementació com una seqüència de mètodes i condicions. Basar la implementació en una \acro{fsm} requeriria un disseny més complex, sense aportar cap avantatge. 
 
A la \autoref{fig:routing_flux_tx} i a la \autoref{fig:routing_flux_rx} es mostren dos diagrames de flux, representant la transmissió i recepció de paquets respectivament. Ambdós diagrames es basen en el disseny exposat en els subapartats anteriors. A la \autoref{fig:routing_flux_txdone} es mostra el diagrama de flux de la transmissió completada, on es pot observar la notificació a la capa superior si aquesta s'hi havia originat. 

De nou, es vol destacar la diferència per evitar notificar a la capa superior d'una transmissió d'un paquet encaminat ---no generat localment---. En la transmissió d'un paquet (\autoref{fig:routing_flux_tx}), es guarda l'identificador generat per la capa d'accés al medi; en el cas d'un encaminament, no.

La implementació d'aquesta capa es troba disponible al fitxer \fitx{routing.cpp}.

\begin{figure}
    \centering
        \includegraphics[width=0.9\linewidth]{imatges/Routing_FluxTX.drawio.pdf}
    \caption{Diagrama de flux de transmissió.}
    \label{fig:routing_flux_tx}
\end{figure}

\begin{figure}
    \centering
        \includegraphics[width=0.9\linewidth]{imatges/Routing_FluxRX.drawio.pdf}
    \caption{Diagrama de flux de recepció.}
    \label{fig:routing_flux_rx}
\end{figure}

\begin{figure}
    \centering
        \includegraphics[width=0.35\linewidth]{imatges/Routing_FluxOnTX.drawio.pdf}
    \caption{Diagrama de flux de transmissió completada.}
    \label{fig:routing_flux_txdone}
\end{figure}

\subsubsection{Exemples de comunicació}
En aquest subapartat es presenten dos exemples de comunicació de la capa d'encaminament, on es representen els mecanismes prèviament explicats. Com en el cas de la capa d'accés al medi, saber quin ha de ser el comportament teòric a través de representacions gràfiques ajuda a entendre millor el funcionament, i a detectar possibles errors en la implementació. 

En ambdós exemples es representen tres dispositius, on el tercer té capacitats LoRaWAN i comunicació amb un \est{gateway}. Per simplicitat, no es representen els missatges de reconeixement, ni els reintents de transmissió, ja que aquests són responsabilitat de la capa d'accés al medi, com s'ha vist en els seus diagrames. Tampoc s'han representat els retards de transmissió dels paquets, considerant-los un aspecte del comportament del canal i, per tant, de la capa d'accés al medi. Per distingir una transmissió a través de la capa d'accés al medi i una a través de LoRaWAN, s'ha utilitzat una línia contínua per a la primera i una línia discontínua per a la segona.

Les taules d'encaminament de cada dispositiu i exemple es representen a la \autoref{tab:routing_taula_enc_exemples}.

\begin{table}[h!]
    \centering
    \begin{tabular}{c c}
        \begin{tabular}{r|ccccc}
            \multicolumn{6}{c}{\small Exemple 1} \\
            \hline
            \multicolumn{1}{c|}{\vcell{}} & \vcell{\textbf{0x01}} & \vcell{\textbf{0x02}} & \vcell{\textbf{0x03}} & \vcell{\textbf{0x04}} & \vcell{\textbf{0x05}} \\[-\rowheight]
            \multicolumn{1}{c|}{\printcellmiddle} & \printcellbottom & \printcellbottom & \printcellbottom & \printcellbottom & \printcellbottom \\ 
            \hline
            \textbf{0x01} & - & 0x04 & 0x04 & 0x04 & - \\
            \textbf{0x02} & 0x03 & - & 0x03 & 0x03 & 0x03 \\
            \textbf{0x03} & 0x04 & 0x02 & - & 0x04 & - \\
            \textbf{0x04} & 0x01 & 0x03 & 0x03 & - & -
        \end{tabular}
        &
        \begin{tabular}{r|cccc}
            \multicolumn{5}{c}{\small Exemple 2} \\
            \hline
            \multicolumn{1}{c|}{\vcell{}} & \vcell{\textbf{0x01}} & \vcell{\textbf{0x02}} & \vcell{\textbf{0x03}} & \vcell{\textbf{0x04}} \\
            [-\rowheight]
            \multicolumn{1}{c|}{\printcellmiddle} & \printcellbottom & \printcellbottom & \printcellbottom & \printcellbottom  \\ 
            \hline
            \textbf{0x01} & -    & 0x03 & 0x03 & 0x04 \\
            \textbf{0x02} & 0x03 & -    & 0x03 & 0x03 \\
            \textbf{0x03} & 0x01 & 0x02 & -    & 0x01 \\
            \textbf{0x04} & 0x01 & 0x01 & 0x01 & -
        \end{tabular}
    \end{tabular}
    \caption{Matrius d'encaminament d'exemple. La cel·la $(x, y)$ indica el dispositiu que $y$ ha d'utilitzar per enviar un paquet a $x$.}
    \label{tab:routing_taula_enc_exemples}
\end{table}


A la \autoref{fig:routing_encaminament_basic_gateway} es mostra un exemple bàsic. Primerament el dispositiu \fitx{0x02} vol enviar un paquet al \fitx{0x04}: obté la ruta per aquest, transmetent-ho a \fitx{0x03}. Aquest rep el paquet, verifica el \acro{ttl}, i obté la següent ruta, que és \fitx{0x04}, el qual rep el paquet, comprova que és el destí final, i ho notifica a la capa superior. 

Un segon exemple de transmissió es realitza quan \fitx{0x02} vol enviar un paquet al \est{gateway}. El dispositiu 2 consulta la taula d'encaminament i veu que el següent salt és el dispositiu 3. Aquest rep el paquet i consulta la seva taula, veient que el següent salt és el \est{gateway}. En rebre el paquet a través de LoRaWAN, realitza la transmissió dels paquets en les finestres de recepció que el dispositiu \fitx{0x04} obre, en tractar-se d'un dispositiu de classe A. Es realitza l'encaminament d'aquest nou paquet, amb el mateix mecanisme que anteriorment.

Per acabar, es representa també com un paquet amb fi de temps de vida (\acro{ttl}) és descartat, de la mateixa manera que un paquet que no pot ser encaminat, ja que no existeix cap entrada a la taula d'encaminament del dispositiu. 

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        device/.style={draw=none, minimum width=1cm, minimum height=0.8cm},
        msg/.style={-Stealth, thick},
        wan/.style={-Stealth, thick, dashed},
        timeout/.style={red, thick, dashed},
        node distance=1cm and 3cm,
        timeline/.style={draw, dashed, white},
        fail/.style={thick, cross at end}
    ]
    
    % Devices
    \node[device] (dev1) at (0,0) {\fitx{0x02}};
    \node[device, right=of dev1] (dev2) {\fitx{0x03}};
    \node[device, right=of dev2] (dev3) {\fitx{0x04}};
    \node[device, right=of dev3] (gw) {\fitx{0x01}};

    \node[above] at ($(gw.south)+(0,-0.1)$) {\tiny(\est{gateway})};

    \draw ($(dev1.south) + (0,0)$) -- ($(dev1.south) + (0,-4.5)$);
    \draw ($(dev2.south) + (0,0)$) -- ($(dev2.south) + (0,-4.5)$);
    \draw ($(dev3.south) + (0,0)$) -- ($(dev3.south) + (0,-4.5)$);
    \draw ($(gw.south) + (0,0)$) -- ($(gw.south) + (0,-4.5)$);

    
    \draw[msg] ($(dev1.south)+(0,-0.5)$) -- ($(dev2.south)+(0,-0.5)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x04}, ttl=3)}};
    \draw[msg] ($(dev2.south)+(0,-0.7)$) -- ($(dev3.south)+(0,-0.7)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x04}, ttl=2)}};

    \draw[msg] ($(dev1.south)+(0,-1.4)$) -- ($(dev2.south)+(0,-1.4)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x01}, ttl=3)}};
    \draw[msg] ($(dev2.south)+(0,-1.6)$) -- ($(dev3.south)+(0,-1.6)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x01}, ttl=2)}};
    \draw[wan] ($(dev3.south)+(0,-1.8)$) -- ($(gw.south)+(0,-1.8)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x01}, ttl=1)}};
    \draw[wan] ($(gw.south)+(0,-2)$) -- ($(dev3.south)+(0,-2)$) node[midway, below] {\tiny{pkt(dst=\fitx{0x03}, ttl=3)}};
    \draw[msg] ($(dev3.south)+(0,-2.2)$) -- ($(dev2.south)+(0,-2.2)$) node[midway, below] {\tiny{pkt(dst=\fitx{0x03}, ttl=2)}};

    \draw[msg] ($(dev1.south)+(0,-3.5)$) -- ($(dev2.south)+(0,-3.5)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x01}, ttl=2)}};
    \draw[msg] ($(dev2.south)+(0,-3.7)$) -- ($(dev3.south)+(0,-3.7)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x01}, ttl=1)}};
    
    \draw[red] ($(dev3.south)+(0,-3.7)$) node[right] {\tiny{\acro{ttl = 1}}};

    \draw[msg] ($(dev1.south)+(0,-4.2)$) -- ($(dev2.south)+(0,-4.2)$) node[midway, above] {\tiny{pkt(dst=\fitx{0x05}, ttl=3)}};

    \draw[red] ($(dev2.south)+(0,-4.2)$) node[right] {\tiny{\acro{sense ruta}}};

    % \node[right] at ($(dev2.south)+(0,-1.6)$) {\tiny{\hspace{2em}Notifica capa superior}};

    
    \end{tikzpicture}
    \caption{Exemple encaminament bàsic amb \est{gateway} LoRaWAN.}
    \label{fig:routing_encaminament_basic_gateway}
\end{figure}

Una altra situació més complexa es pot produir quan la xarxa es troba separada en dues xarxes, amb un \est{gateway} LoRaWAN al mig. En aquest cas, el comportament és similar a l'observat anteriorment, on el \est{gateway} fa les transmissions dels paquets únicament després de rebre'n un altre, ja que es tracten de dispositius de classe A. Així, si un dispositiu vol enviar un paquet a un dispositiu de la xarxa contrària, la correcta transmissió d'aquest paquet dependrà de la transmissió d'un altre paquet originat a la xarxa contraria, per tal que pugui obrir la finestra de recepció necessària.

A més, es requereix també un servidor d'aplicació, encarregat de processar els paquets que el \est{gateway} rep, i generar els \est{downlinks} corresponents. Malgrat aquests requisits, aquest exemple permet i\l.lustrar les capacitats d'encaminament de la capa, que no tenen perquè estar limitades a una única xarxa. El seu diagrama es pot trobar representat a la \autoref{fig:routing_encaminament_complex_gateway}.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        device/.style={draw=none, minimum width=1cm, minimum height=0.8cm},
        msg/.style={-Stealth, thick},
        wan/.style={-Stealth, thick, dashed},
        timeout/.style={red, thick, dashed},
        node distance=1cm and 3cm,
        timeline/.style={draw, dashed, white},
        fail/.style={thick, cross at end}
    ]
    
    % Devices
    \node[device] (dev1) at (0,0) {\fitx{0x02}};
    \node[device, right=of dev1] (dev2) {\fitx{0x03}};
    \node[device, right=of dev2] (gw) {\fitx{0x01}};
    \node[device, right=of gw] (dev3) {\fitx{0x04}};

    \node[above] at ($(gw.south)+(0,-0.1)$) {\tiny(\est{gateway})};

    \draw ($(dev1.south) + (0,0)$) -- ($(dev1.south) + (0,-2.5)$);
    \draw ($(dev2.south) + (0,0)$) -- ($(dev2.south) + (0,-2.5)$);
    \draw ($(gw.south) + (0,0)$) -- ($(gw.south) + (0,-2.5)$);
    \draw ($(dev3.south) + (0,0)$) -- ($(dev3.south) + (0,-2.5)$);


    \draw[wan] ($(dev3.south)+(0,-0.5)$) -- ($(gw.south)+(0,-0.5)$) node[midway, above] {\tiny{pkt1(dst=\fitx{0x03}, ttl=3)}};
    \draw[blue] ($(gw.south)+(0,-0.5)$) node[left] {\tiny{\acro{programa downlink pkt1}}};
    
    \draw[msg] ($(dev1.south)+(0,-0.9)$) -- ($(dev2.south)+(0,-0.9)$) node[midway, above] {\tiny{pkt2(dst=\fitx{0x04}, ttl=3)}};
    \draw[wan] ($(dev2.south)+(0,-1.1)$) -- ($(gw.south)+(0,-1.1)$) node[midway, above] {\tiny{pkt2(dst=\fitx{0x04}, ttl=2)}};
    \draw[blue] ($(gw.south)+(0,-1.1)$) node[right] {\tiny{\acro{programa downlink pkt2}}};
    \draw[wan] ($(gw.south)+(0,-1.3)$) -- ($(dev2.south)+(0,-1.3)$) node[midway, below] {\tiny{pkt1(dst=\fitx{0x03}, ttl=2)}};

    \draw[wan] ($(dev3.south)+(0,-2.1)$) -- ($(gw.south)+(0,-2.1)$) node[midway, above] {\tiny{pkt3(dst=\fitx{0x02}, ttl=3)}};
    \draw[blue] ($(gw.south)+(0,-2.1)$) node[left] {\tiny{\acro{programa downlink pkt3}}};
    \draw[wan] ($(gw.south)+(0,-2.3)$) -- ($(dev3.south)+(0,-2.3)$) node[midway, below] {\tiny{pkt2(dst=\fitx{0x04}, ttl=1)}};
    \end{tikzpicture}
    \caption{Exemple encaminament entre xarxes separades per \est{gateway} LoRaWAN.}
    \label{fig:routing_encaminament_complex_gateway}
\end{figure}



\subsection{Capa de transport}
La funció d'aquesta capa és la de gestionar la transmissió de missatges entre el dispositiu transmissor, l'origen, i el receptor final, el destí. A més, també ofereix la possibilitat d'implementar un mecanisme de fiabilitat, intentant garantir que el missatge arribi correctament al destí final, i que no es rebin missatges duplicats. 

Cal diferenciar aquest mecanisme de fiabilitat del que ofereix la capa d'accés al medi, que únicament intenta garantir que el missatge arribi correctament al següent salt. Després de realitzar els intents màxims de retransmissió, el missatge es descarta si no s'ha pogut transmetre. La capa de transport, en canvi, incorpora mecanismes de fiabilitat amb una visió global, indiferentment dels mètodes que apliquen les capes inferiors.

La gestió de la recepció de missatges duplicats és també una qüestió important en xarxes encaminades. La transmissió d'un missatge es podria realitzar a través de diferents rutes, arribant al destí final per múltiples camins. És essencial poder identificar cada missatge i descartar els duplicats, assegurant així una comunicació coherent. 

A més, s'encarrega també de gestionar els missatges de les diferents aplicacions que poden existir a la capa d'aplicació, redirigint cada missatge a la seva aplicació corresponent.


\subsubsection{Estructura de les trames}
Seguint l'estructura del model \acro{tcp/ip}, els missatges d'aquesta capa s'anomenen \emph{segments}, permetent diferenciar-los dels paquets de la capa d'encaminament, o de les trames de la capa d'accés al medi. 

Per tal de poder identificar cada missatge, i evitar duplicitats, s'inclou un \emph{identificador} de missatge. S'ha dissenyat d'una longitud de \SI{2}{\byte}, permetent així un màxim de \num{65535} missatges diferents. La distinció entre aquest identificador i el de la capa d'accés al medi és que aquest és global, mantenint-se des de l'emissor fins al receptor final. En canvi, l'identificador de la capa d'accés al medi és local, i es reinicia cada vegada que es realitza una nova transmissió. Així, la probabilitat de co\l.lisió d'identificadors és menor que en la capa d'accés al medi, ja que la quantitat d'identificadors generats és menor. Malgrat això, s'ha optat per mantenir la mateixa longitud d'identificador, reduïnt la probabilitat de co\l.isió d'identifiadors en aquesta capa, incrementant així la fiabilitat d'extrem a extrem. 

El mecanisme de fiabilitat és semblant a l'implementat a la capa d'accés al medi, on el receptor reconeix la recepció del missatge a través d'un missatge de reconeixement. Així, és necessari disposar d'un camp d'\acro{ack}. Per oferir la possibilitat d'utilitzar o no aquest mecanisme, s'ha inclòs un camp que indica la so\l.licitud del reconeixement. Ambdós camps d'han implementat com un únic bit, inclosos dins un camp de \est{flags}. Així, el camp de \est{flags} ocupa \SI{1}{\byte}, utilitzant un bit pel camp \emph{ACKRequest}, i un per \emph{ACKResponse}.

Per gestionar el redireccionament de segments cap a l'aplicació corresponent de la capa superior s'ha inclòs un camp per identificar l'aplicació, conegut com a \emph{port} en el model \acro{tcp/ip}. Per tal d'aprofitar l'espai disponible del segment, s'han utilitzat els sis bits restants del camp de \est{flags}, permetent un màxim de 64 aplicacions diferents. 

Per acabar, inclou els camps de \emph{longitud} i de \emph{dades}. Tenint en compte que un paquet pot tenir una longitud màxima de dades de \SI{244}{\byte}, i que el segment formarà part d'aquestes dades, la longitud màxima del segment serà de \SI{240}{\byte}. Així, el camp de dades, té una longitud màxima de \SI{240}{\byte}, sent els \SI{4}{\byte} restants per a la resta de camps. La longitud del camp de \emph{longitud} és d'\SI{1}{\byte}, suficient per a representar aquesta longitud màxima.

A la \autoref{fig:segment_transport} es pot observar l'estructura del segment de la capa de transport, amb els camps comentats anteriorment.

\begin{figure}
    \centering
    \begin{bytefield}[bitwidth=1.2em]{16}
        \bitheader{0,7,8,15} \\
        \bitbox{16}{Identificador} \\
    \bitbox{6}{Port} & \bitbox{1}{\tiny \rotatebox{90}{ACK}\rotatebox{90}{Req}} & \bitbox{1}{\tiny \rotatebox{90}{ACK}\rotatebox{90}{Resp}} & \bitbox{8}{Longitud} \\
    \wordbox{3}{Data \tiny {(màx. \SI{240}{\byte})}}
    \end{bytefield}
    \caption{Estructura del segment de la capa de transport.}
    \label{fig:segment_transport}
\end{figure}
\subsubsection{Transmissió}
Com en la capa d'encaminament, la transmissió en la capa de transport és simple: utilitza la interfície exposada per la capa d'encaminament. En finalitzar la transmissió, la capa d'encaminament notificarà a través d'un \est{callback} aquesta finalització. Com en la capa d'accés al medi, el mètode de generació de l'identificador és aleatori.

La complexitat recau en la gestió de la fiabilitat. La transmissió d'un segment es pot realitzar de forma no fiable o fiable. En el primer cas, el dispositiu no espera cap reconeixement, i únicament utilitza la interfície de la capa d'encaminament per realitzar la transmissió, despreocupant-se del resultat. En el segon cas, el dispositiu espera rebre un segment de reconeixement, transmès pel receptor final. En cas de no rebre'l en un temps determinat, es retransmet de nou el segment. 

A causa de la cua de transmissió a la capa d'accés al medi, l'inici del temps d'espera de recepció del reconeixement no es pot iniciar després d'utilitzar la interfície de la capa inferior, ja que la transmissió no té per què produir-se immediatament. Així, només es pot iniciar el temporitzador quan la capa inferior notifica la transmissió del segment, a través del \est{callback} corresponent.

Per permetre aquest comportament, es guarda informació addicional d'una transmissió, en una estructura de metadades:
\begin{itemize}
    \item \emph{PDU}. Conté el \emph{Protocol Data Unit}, és a dir, el segment complet, incloent les dades i capçaleres.
    \item \emph{ID}. L'identificador assignat per la capa d'accés al medi, amb el qual es podrà identificar la transmissió en els esdeveniments de fi de transmissió o de transmissió errònia.
    \item \emph{RX}. L'adreça del receptor del segment.
    \item \emph{isSent}. Un booleà per indicar si el segment ja s'ha enviat o no. S'actualitza quan es rep la notificació de fi de transmissió.
    \item \emph{ackTimeout}. Indica l'instant de temps en mi\l.lisegons en què finalitza l'espera de reconeixement. 
    \item \emph{Reintents}. Indica el nombre de reintents de transmissió que s'han realitzat per un segment.
    \item \emph{Tasca}. Tasca del gestor de tasques que s'encarrega de gestionar el temporitzador d'espera del reconeixement. Permet cance\l.lar la tasca si es rep el reconeixement.
\end{itemize}

Així, quan finalitza la transmissió d'un segment fiable, es determina en quin instant finalitza el temps d'espera de recepció de l'\acro{ack}, i es guarda a les metadades. A més, es crea una tasca que generarà l'esdeveniment de fi d'espera d'\acro{ack} quan es compleixi el temps d'espera, la qual també es guarda a les metadades, permetent cance\l.lar-la si es produeix el reconeixement. Més informació sobre la fiabilitat es pot trobar al \autoref{subsubsec:transport_fiabilitat}.

Les metadades es guarden tant per a transmissions fiables com no fiables. Malgrat no ser necessari determinar el temps d'espera d'un reconeixement en un segment no fiable, guardar les metadades és útil per poder notificar a la capa superior.

Les notificacions implementades en aquesta capa són similars a les de la capa d'encaminament: fi de transmissió i error de transmissió.
\begin{itemize}
    \item En segments fiables, la notificació de fi de transmissió es genera quan s'ha rebut el reconeixement per part del receptor. En cas contrari, si no es rep el reconeixement i s'esgoten els intents de transmissió, es genera una notificació d'error de transmissió.
    \item En segments no fiables, la notificació de fi de transmissió es genera quan la capa d'accés al medi ha pogut lliurar el segment al següent salt. Aquesta notificació no garanteix la recepció del segment per part del receptor final, i únicament indica que s'ha pogut transmetre. D'altra banda, si la capa d'accés al medi notifica que no s'ha pogut transmetre, es genera un notificació d'error de transmissió, indicant que el segment no s'ha pogut transmetre ni al següent salt.
\end{itemize}
Aplicar notificacions en un segment no fiable pot semblar contradictori, però pot ser útil per a les aplicacions que volen saber si el segment, com a mínim, s'ha pogut transmetre des del dispositiu. Utilitzant LoRa, les transmissions poder ser lentes, i aquest tipus de notificacions poden oferir una alternativa més llegura.
\subsubsection{Recepció}
Es produeix una recepció d'un segment quan la capa inferior, la d'encaminament, ho notifica a través del \est{callback} configurat. Quan es rep un segment, es verifica el camp \emph{ACKRequest} dels \est{flags}. En cas que el segment rebut so\l.liciti un reconeixement, es genera un segment amb el camp \emph{ACKResponse} actiu, i es transmet cap al transmissor de l'anterior segment, utilitzant el mecanisme exposat en el subapartat anterior.

Seguidament es verifica si el segment s'havia rebut anteriorment, consultant el camp d'identificador del segment rebut amb els identificadors dels últims segments rebuts. Aquest disseny és similar a l'utilitzat a la capa d'accés al medi, on es guarden les últimes trames rebudes. De nou, la mida d'aquesta cua és configurable, però s'ha de tenir en compte que si és massa petita, es poden produir falsos positius, i si és massa gran, hi podrien haver co\l.lisions d'identificadors de segments diferents.

Si ja s'havia rebut anteriorment l'identificador, ja que existeix a la cua de segments rebuts, s'atura el processament del segment, i es descarta. En cas contrari, es guarda l'identificador a la cua, i es notifica a la capa superior de la recepció d'un nou segment.
\subsubsection{Gestió de múltiples aplicacions}
% hi poden haver múltiples capes superiors (aplicacions)
% A quina cal enviar les notificacions?
Una característica d'aquesta capa és que pot disposar de múltiples capes superiors, o aplicacions. Això permet que cada aplicació pugui gestionar els seus propis missatges, els quals poden tenir estructures diferents, sense interferir entre elles. 

Per a implementar aquest comportament, és necessari que la capa de transport conegui les interfícies a través de les quals notificar la recepció o transmissió d'un missatge per a cada aplicació. Per fer-ho, es dissenya una taula de ports, on cada port s'associa a les funcions de notificació específiques per a cada aplicació. Aquesta taula permet utilitzar múltiples \emph{callbacks} per gestionar la recepció i la fi de transmissió de segments, amb un \emph{callback} dedicat a cada aplicació. A la \autoref{tab:taula_ports} es pot observar un exemple de taula de ports, on es pot veure com tres aplicacions diferents poden gestionar la recepció i transmissió de segments a través de les seves propies interfícies.

\begin{table}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port} & \textbf{Transmissió} & \textbf{Error transmissió} & \textbf{Recepció} \\
        \midrule
        \fitx{00} & \fitx{TxDone1()} & \fitx{TxErr1()} & \fitx{Rx1()} \\
        \fitx{17} & \fitx{TxDone2()} & \fitx{TxErr2()} & \fitx{Rx2()} \\
        \fitx{63} & \fitx{TxDoneN()} & \fitx{TxErrN()} & \fitx{RxN()} \\
        \bottomrule
    \end{tabular}
    \centering
    \caption{Exemple de taula de ports.}
    \label{tab:taula_ports}
\end{table}

Així, quan es rep un segment amb el port 17, la capa de transport utilitzarà la interfície \fitx{Rx2} per notificar la recepció del segment únicament a l'aplicació interessada.

La taula de ports pot tenir fins a un màxima de 64 entrades, una per cada possible port. Per cada un d'aquests, es pot assignar únicament una interfície de notificació, garantint així que una única aplicació sigui notificada. En cas que no s'hagi assignat cap interfície a un port, la capa de transport no podrà notificar-ho, fent que l'esdeveniment es perdi.

Un altre problema de disposar de múltiples capes superiors és que cada aplicació pot intentar inicialitzar la capa de transport. Per evitar-ho, és important que la capa de transport guardi l'estat d'inicialització i, en cas que es vulgui inicialitzar de nou, simplement ho «simuli», sense realitzar cap acció addicional. Aquest mateix mecanisme cal aplicar-lo també a la deinicialització: en cas que una aplicació intenti deinicialitzar la capa de transport, cal verificar que no hi ha cap altra aplicació que la utilitzi, i en cas que sí, no realitzar cap acció addicional. Així, es garanteix que la capa de transport es pot inicialitzar i deinicialitzar múltiples vegades, sense interferir amb les aplicacions que la utilitzin.
\subsubsection{Fiabilitat}
\label{subsubsec:transport_fiabilitat}
% « »
Com s'ha comentat anteriorment, la implementació de la fiabilitat es basa en un mecanisme de reconeixement, similar al de la capa d'accés al medi.
Quan s'ha realitzat la transmissió d'un segment fiable, s'inicia un temporitzador a través del gestor de tasques, que genera un esdeveniment quan finalitza el temps d'espera d'\acro{ack}. Quan es produeix aquest esdeveniment, s'obtenen les metadades de la transmissió, i es reintenta la transmissió de nou, repetint el procediment.

És important destacar que, si no es pot realitzar la transmissió del segment (per exemple, perquè la capa d'accés al medi no pot transmetre), s'aplicarà el mateix mecanisme. En aquest cas, la capa inferior ho notifica a través del \est{callback} de transmissió errònia, en lloc del de fi de transmissió.

Per tal de poder identificar quin segment un missatge de reconeixement ---aquell que té el camp \emph{ackResponse} actiu--- reconeix, s'estableix que l'identificador d'aquests segments sigui el mateix que el del segment original, el que reconeixen. Així, en rebre un recnoeixement, la capa de transport pot consultar la llista de metadades, que conté l'identificador del segment original, i així poder identificar el segment i aturar el temporitzador d'espera d'\acro{ack}.

El temps d'espera de recepció del reconeixement no és fix, sinó que depèn del nombre de retransmissions que s'han realitzat anteriorment, seguint una funció exponencial. Gràcies a això, el temps d'espera s'incrementa com més reintents s'han realitzat, ajustant-se a les condicions de la xarxa.
Aquest temps ve determinat per l'expressió $k\cdot 2^r$, on \emph{k} és un valor constant i configurable, i \emph{r} el nombre de reintents realitzats. El valor de \emph{k} cal configurar-lo adequadament per evitar generar \est{timeouts} prematurs, i per evitar un excés de temps d'espera:
\begin{itemize}
    \item Hauria de verificar $k\ge (2n-1)\cdot t_{tx}$, on \emph{n} és el nombre de dispositius en la ruta més llarga de la xarxa, sense incloure el dispositiu emissor. És així ja que cada node ha de realitzar una transmissió al següent salt del segment (d'aquí el factor \emph{n}), i també haurà de fer-ho pel missatge de reconeixement del receptor final (d'aquí el factor \emph{2}). A més, cal recordar que l'inici del temps d'espera s'inicia després de transmetre el segment al següent salt, d'aquí el terme \emph{-1}.
    \item Hauria de considerar el temps d'una transmissió a través de LoRaWAN. Si la transmissió d'un segment té com a destí el \est{gateway}, el dispositiu amb capacitats LoRaWAN haurà, abans de generar el segment de reconeixement, transmetre les dades a través de LoRaWAN. Aquest temps depèn de la configuració del canal i de l'\acro{adr}, fent que sigui difícil d'establir ja que no es coneix prèviament. De forma experimental, s'ha observat com pot introduir un retard de múltiples segons, sent adequat deixar un marge de mínim 5 segons. 
\end{itemize}
Aquest criteri estableix el temps mínim d'espera, considerant que per a cada dispositiu de la ruta es requereix únicament una transmissió, i que el retard de processametn és nul. Si s'estableix un temps mínim d'espera menor a aquest, és segur que es produiran \est{timeouts} prematurs.

Establir un límit superior pel temps d'espera no és trivial. Caldria tenir en compte el nombre de retransmissions màximes de la capa d'accés al medi, i la congestió de la xarxa, que pot introduir retards a causa del \acro{beb} aplicat. 
\subsubsection{Detalls d'implementació}
La implementació de la cua dels últims identificadors de segments rebuts s'ha realitzat a través d'una cua circular, de mida màxima configurable. Gràcies a l'ús d'aquesta, la capa de transport únicament s'encarrega d'afegir nous elements, i la cua circular elimina de forma automàtica els més antics. La seva implementació es pot consultar a \fitx{utils/RingBuffer.cpp}.

Apareix una qüestió important en els missatges de reconeixement quan el destí és el \est{gateway}. Com s'ha mencionat anteriorment, aquests s'encarreguen de retransmetre els missatges rebuts al servidor de xarxa LoRaWAN, i no tenen capacitat de generar missatges. Així, hauria de ser un servidor d'aplicació qui processés el missatge rebut i, llavors, programés l'enviament d'un \est{downlink} amb el segment de reconeixement a través del \est{gateway}.
Malgrat semblar una solució vàlida, cal recordar que s'utilitzen dispositius de classe A, els quals només poden rebre missatges després de realitzar una transmissió. Així, l'enviament del missatge de reconeixement no es realitzaria fins que el dispositiu transmetés un nou missatge, un \est{uplink}. Aquest comportament afegeix molta latència, i faria dependre el missatge de reconeixement de la transmissió d'un nou missatge.

La solució que s'ha implementat és considerar el dispositiu amb capacitats LoRaWAN ---es pot comunicar amb el \est{gateway}--- com una «extensió» del \est{gateway}. Així, quan aquest fa un encaminament a través de LoRaWAN, la capa d'encaminament genera també l'esdeveniment de recepció de nou segment, permetent a la capa de transport processar el segment prèviament rebut, i generar el missatge de reconeixement en cas de ser necessari.

Aquesta solució no és la més elegant, i implica que un dispositiu que no és el destí final processi el segment rebut. No obstant això, si es veu el dispositiu amb capacitats LoRaWAN com un dispositiu diferent a la resta, considerant-lo, com s'ha dit anteriorment, com una «extensió» del \est{gateway}, la solució és vàlida per evitar que la correcta transmissió d'un segment depengui de la transmissió d'un de diferent. Gràcies a la llibreria de RadioLib, que ja incorpora mecanismes de fiabilitat a través de LoRaWAN ---també mitjançant reconeixements---, no és necessari implementar-ho manualment.

\subsubsection{Exemples de comunicació}
En aquest subapartat es presenta un exemple de comunicació, representant les característiques d'aquesta capa. Per simplicitat, es dona per suposat que les taules d'encaminament es troben ben definides i, com en els exemples d'encaminament, no es representen els temps de propagació ni de transmissió, així com els missatges de reconeixement de la capa d'accés al medi. A més, tampoc s'inclouen els identificadors dels ports de cada segment, ja que no són rellevants per a les situacions exposades, i únicament s'utilitzen en les notificacions a la capa superior.

A la \autoref{fig:transport_exemple_1} es representa el diagrama de l'exemple. El dispositiu \fitx{0x02} inicia una transmissió fiable cap al dispositiu \fitx{0x03}; aquest no rep el reconeixement, i aplica fins a un màxim de 2 reintents addicionals. És important destacar com el temps d'espera de recepció del reconeixement incrementa exponencialment per cada transmissió, i com la notificació de transmissió fallida es produeix després d'aplicar aquest temps. 

Para\l.lelament, el dispositiu \fitx{0x03} realitza una transmissió fiable cap al dispositiu \fitx{0x01}, el \est{gateway}. En aquest cas, és el dispositiu amb capacitats LoRaWAN, \fitx{0x04}, qui rep el segment, notifica la capa superior, i genera el segment de reconeixement, sent aquesta la solució exposada al problema dels dispositius de classe A. Quan \fitx{0x03} rep el reconeixement, la capa de transport notifica la fi de transmissió a la capa superior.
Es vol destacar que la transmissió a través de LoRaWAN (línia discontínua) és independent de la capa de transport, i que únicament s'ha representat per poder mostrar aquesta situació característica, on no és el dispositiu final (\est{gateway}) qui genera el reconeixement.

Seguidament, el dispositiu \fitx{0x03} realitza dues transmissions no fiables cap a \fitx{0x01} i \fitx{0x04}. La primera d'elles és satisfactòria, i el dispositiu genera la notificació de fi de transmissió després de finalitzar la transmissió al següent dispositiu, que no té perquè ser el destí final. La segona transmissió no es pot realitzar, i el dispositiu genera la notificació d'error de transmissió després del primer intent, sense aplicar temps d'espera.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        device/.style={draw=none, minimum width=1cm, minimum height=0.8cm},
        msg/.style={-Stealth, thick},
        wan/.style={-Stealth, thick, dashed},
        timeout/.style={red, thick, dashed},
        node distance=3.3cm,
        timeline/.style={draw, dashed, white},
        fail/.style={thick, cross at end}
    ]
    
    % Devices
    \node[device] (dev1) at (0,0) {\fitx{0x02}};
    \node[device, right=of dev1] (dev2) {\fitx{0x03}};
    \node[device, right=of dev2] (dev3) {\fitx{0x04}};
    \node[device, right=of dev3] (gw) {\fitx{0x01}};

    \node[above] at ($(gw.south)+(0,-0.1)$) {\tiny(\est{gateway})};

    \draw ($(dev1.south) + (0,0)$) -- ($(dev1.south) + (0,-4.5)$);
    \draw ($(dev2.south) + (0,0)$) -- ($(dev2.south) + (0,-4.5)$);
    \draw ($(gw.south) + (0,0)$) -- ($(gw.south) + (0,-4.5)$);
    \draw ($(dev3.south) + (0,0)$) -- ($(dev3.south) + (0,-4.5)$);

    \draw[msg] ($(dev2.south)+(0,-0.5)$) -- ($(dev3.south)+(0,-0.5)$) node[midway, above] {\tiny{seg(id=\fitx{0x1234}, ackreq=\fitx{1}), dst=\fitx{0x01}}};
    \draw[wan] ($(dev3.south)+(0,-0.7)$) -- ($(gw.south)+(0,-0.7)$) node[midway, above] {\tiny{seg(id=\fitx{0x1234}, \dots)}};
    \draw[msg] ($(dev3.south)+(0,-0.9)$) -- ($(dev2.south)+(0,-0.9)$) node[midway, below] {\tiny{seg(id=\fitx{0x1234}, ackresp=\fitx{1}), dst=\fitx{0x03}}};
    \draw[blue] ($(dev2.south)+(0,-0.9)$) node[left] {\tiny{\acro{tx}}};
    \draw[blue] ($(dev3.south)+(0,-0.5)$) node[right] {\tiny{\acro{rx}}};
    
    \draw[fail] ($(dev1.south)+(0,-0.5)$) -- ($ (dev1.south) !0.5! (dev2.south) + (0, -0.5)$) node[above] {\tiny{seg(id=\fitx{0xABCD}, ackreq=\fitx{1}}), dst=\fitx{0x03}};
    \draw[fail] ($(dev1.south)+(0,-1)$) -- ($ (dev1.south) !0.5! (dev2.south) + (0, -1)$) node[above] {\tiny{seg(id=\fitx{0xABCD}, \dots)}};
    \draw[fail] ($(dev1.south)+(0,-2)$) -- ($ (dev1.south) !0.5! (dev2.south) + (0, -2)$) node[above] {\tiny{seg(id=\fitx{0xABCD}, \dots)}};
    % \draw[fail] ($(dev1.south)+(0,-4)$) -- ($ (dev1.south) !0.5! (dev2.south) + (0, -4)$) node[above] {\tiny{seg(id=\fitx{0xABCD}, \dots)}};
    \draw[blue] ($(dev1.south)+(0,-4)$) node[left] {\tiny{\acro{txerr}}};

    \draw[msg] ($(dev2.south)+(0,-2.5)$) -- ($(dev3.south)+(0,-2.5)$) node[midway, above] {\tiny{seg(id=\fitx{0x9876}, ackreq=\fitx{0}), dst=\fitx{0x04}}};
    \draw[wan] ($(dev3.south)+(0,-2.7)$) -- ($(gw.south)+(0,-2.7)$) node[midway, above] {\tiny{seg(id=\fitx{0x9876}, \dots)}};
    \draw[blue] ($(dev2.south)+(0,-2.5)$) node[left] {\tiny{\acro{tx}}};
    \draw[blue] ($(dev3.south)+(0,-2.5)$) node[right] {\tiny{\acro{rx}}};

    \draw[fail] ($(dev2.south)+(0,-3.5)$) -- ($ (dev2.south) !0.5! (dev3.south) + (0, -3.5)$) node[above] {\tiny{seg(id=\fitx{0x0001}, ackreq=\fitx{0}), dst=\fitx{0x04}}};
    \draw[blue] ($(dev2.south)+(0,-3.5)$) node[left] {\tiny{\acro{txerr}}};

    \end{tikzpicture}
    \caption{Exemple de comunicació entre }
    \label{fig:transport_exemple_1}
\end{figure}

\subsection{Capa d’aplicació}
La capa d'aplicació és la més alta del protocol, i s'encarrega de gestionar les aplicacions que l'utilitzen. Tot i que no forma part del protocol, actua com a interfície entre aquest i les aplicacions, permetent que cada aplicació pugui definir i implementar la seva pròpia capa d'aplicació de manera independent, sense interferir amb la resta. 

En ser independent, poden coexistir múltiples aplicacions, on cadascuna defineix la seva pròpia estructura de dades. Tal com s'ha vist en la capa de transport, cada aplicació s'identifica mitjançant un port, que ha de ser únic. Gràcies a la implementació de la capa de transport, les aplicacions només són notificades dels missatges que els corresponen, de manera que no cal que cada una filtri els missatges rebuts.

Així, el desenvolupament de la capa d'aplicació és una tasca de l'usuari final, i dependrà completament dels requisits i característiques específiques de cada cas. A continuació s'indiquen, com a exemple, alguns protocols de capa d'aplicació que podrien existir:
\begin{itemize}
    \item \emph{Configuració dinàmica}. Permet modificar paràmetres del protocol durant el seu funcionament, com ara la potència de transmissió, el nombre d’intents de retransmissió o el temps d’espera per a la recepció dels \acro{ack} de la capa d’accés al medi.
    \item \emph{Gestió de la xarxa}. Ofereix la possibilitat d'afegir o eliminar nodes i, per tant, de modificar les taules de rutes dels dispositius.
    \item \emph{Baix consum}. Gestiona els modes de baix consum dels nodes, proporcionant mecanismes de sincronització amb la resta de dispositius per evitar la pèrdua de funcionalitat d’encaminament.
\end{itemize}

Al \autoref{chap:adaptacio_baix_consum} es detalla la implementació de l'últim exemple, definint la situació d'ús i els mecanismes utilitzats.

\section{Proves i validació del protocol}
Per tal de verificar el correcte funcionament del protocol, s'han desenvolupat fitxers de prova específics per a cada capa. Aquests fitxers implementen una situació de comunicació coneguda on el comportament del protocol és previsible, i permeten verificar-ne el seu correcte funcionament. Part d'aquestes situacions controlades s'han basat en els diagrames d'exemple exposats anteriorment. Aquests fitxers de prova són útils també com a exemple d'ús del protocol, i poden servir com a base per a nous protocols de cada capa. Es poden consultar a la ruta \fitx{firmware/exemples}.

La implementació del protocol inclou traces de depuració, distingides entre informació, avís, i error, amb les quals és possible conèixer l'estat del protocol en cada moment. 

Les proves s'han realitzat de forma manual, observant l'estat del sistema a través de les traces, i verificant el comportament del protocol a través dels diagrames de funcionament previst. Part de les proves han requerit d'intervenció manual, com ara la desconnexió de dispositius (per simular-ne una fallada), o la programació d'enviaments de \est{downlinks} a través de \acro{ttn}.

Una clara limitació ha estat la manca de dispositius. A causa de només disposar d'un \est{gateway} i de dos dispositius, no s'ha pogut verifica el funcionament del protocol en grans xarxes, o en topologies complexes. 

TODO: Verificació de distància?

TODO: Posar aquí un exemple de log de comunicació?

En el procés de validació es van observar inconsistències en el funcionament del protocol. Les més rellevants, que impedien el funcionament total del protocol, són les següents:
\begin{itemize}
    \item Els temps d'espera de recepció d'\acro{ack} no eren coherents, i resultaven en \est{timeouts} prematurs. Això es devia a iniciar el temporitzador de recepció d'\acro{ack} quan s'iniciava la transmissió, i no en la seva finalització.
    \item Després de realitzar una verificació de l'estat del canal (a través de \acro{cad}), en transductor no es posava, de forma automàtica, en estat de recepció. Això provocava que no es produís la interrupció de recepció i, per tant, que no es processessin els missatges rebuts.
    \item Configuració de la ràdio en LoRaWAN i LoRa. Després de realitzar una transmissió a través de LoRaWAN, no es rebien missatges enviats a través de LoRa. Això es devia a que la ràdio quedava amb la configuració de LoRaWAN, i no es tornava a configurar per a LoRa. Es va solucionar a través de la capa d'abstracció \est{LoRa}, superior a \est{LoRaWAN} i {LoRaRAW}.
\end{itemize}

Després de les verificacions, cada capa del protocol verifica els requisits prèviament definits, amb la fiabilitat i el baix consum de les transmissions com a objectius principals. Tot i que no s'han pogut realitzar proves en entorns reals i topologies més complexes, es considera que el protocol estableix una base funcional i estable per a la seva aplicació.

\chapter{Adaptació a entorns de baix consum}
\label{chap:adaptacio_baix_consum}
\section{Descripció de l’escenari: xarxa lineal de sensors}
\section{Limitacions del protocol sense optimitzacions energètiques}
% \section{Estratègies de sincronització i activació temporal}
\section{Estratègies de sincronització}
\subsection{Sincronització explícita}
\subsection{Sincronització implícita}
% \subsection{Avantatges i inconvenients de cada enfocament}
% \subsection{Compromisos entre consum i generalitat del protocol}

\chapter{Conclusions}
% \section{Resultats assolits}
% \section{Limitacions del disseny final}
% \section{Punts clau de millora}

\chapter{Treball futur}
% \section{Suport a topologies més complexes}
% \section{Optimització del consum energètic}
% \section{Integració amb LoRaWAN o altres protocols}

% https://www.latex-tables.com/
% configurar amb opció de SCALE
\begin{figure}
    \centering
    \resizebox{\linewidth}{!}{%
        \begin{tabular}{l||cccccccccccccccccc} 
            \hhline{~|t|~~~~~~~----~~~~~~~}
            \textbf{N1} &                          &                            &                            &                            &                            &                            & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{RX2:9} & \multicolumn{1}{c|}{TX1:9} & \multicolumn{1}{c|}{{\cellcolor[rgb]{0.753,0.749,0.737}}RXG} & \multicolumn{1}{c|}{{\cellcolor[rgb]{0.753,0.749,0.737}}TXG} &                                                              &                                                              &                          &                          &                          &                          &                           \\ 
            \hhline{~||~~~~~~------~~~~~~}
            \textbf{N2} &                          &                            &                            &                            &                            & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{RX3:9} & \multicolumn{1}{c|}{TX2:9} &                            & \multicolumn{1}{c|}{}                                        & \multicolumn{1}{c|}{{\cellcolor[rgb]{0.753,0.749,0.737}}RXG} & \multicolumn{1}{c|}{{\cellcolor[rgb]{0.753,0.749,0.737}}TXG} &                                                              &                          &                          &                          &                          &                           \\ 
            \hhline{~||~~~~~---~~---~~~~~}
            \textbf{N3} &                          &                            &                            &                            & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{RX4:9} & \multicolumn{1}{c|}{TX3:9} &                            &                            &                                                              & \multicolumn{1}{c|}{}                                        & \multicolumn{1}{c|}{{\cellcolor[rgb]{0.753,0.749,0.737}}RXG} & \multicolumn{1}{c|}{{\cellcolor[rgb]{0.753,0.749,0.737}}TXG} &                          &                          &                          &                          &                           \\ 
            \hhline{~||~~~~---~~~~---~~~~}
            \textbf{N4} &                          &                            &                            & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{RX5:9} & \multicolumn{1}{c|}{TX4:9} &                            &                            &                            &                                                              &                                                              & \multicolumn{1}{c|}{}                                        & \multicolumn{1}{c|}{{\cellcolor[rgb]{0.753,0.749,0.737}}RXG} & \multicolumn{1}{c|}{TXG} &                          &                          &                          &                           \\ 
            \cline{5-7}\cline{14-16}
            \textbf{N5} &                          &                            & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{RX6:9} & \multicolumn{1}{c|}{TX5:9} &                            &                            &                            &                            &                                                              &                                                              &                                                              & \multicolumn{1}{c|}{}                                        & \multicolumn{1}{c|}{RXG} & \multicolumn{1}{c|}{TXG} &                          &                          &                           \\ 
            \cline{4-6}\cline{15-17}
            \textbf{N6} &                          & \multicolumn{1}{c|}{}      & \multicolumn{1}{c|}{RX7:9} & \multicolumn{1}{c|}{TX6:9} &                            &                            &                            &                            &                            &                                                              &                                                              &                                                              &                                                              & \multicolumn{1}{c|}{}    & \multicolumn{1}{c|}{RXG} & \multicolumn{1}{c|}{TXG} &                          &                           \\ 
            \cline{3-5}\cline{16-18}
            \textbf{N7} & \multicolumn{1}{c|}{}    & \multicolumn{1}{c|}{RX8:9} & \multicolumn{1}{c|}{TX7:9} &                            &                            &                            &                            &                            &                            &                                                              &                                                              &                                                              &                                                              &                          & \multicolumn{1}{c|}{}    & \multicolumn{1}{c|}{RXG} & \multicolumn{1}{c|}{TXG} &                           \\ 
            \cline{2-4}\cline{17-19}
            \textbf{N8} & \multicolumn{1}{c|}{RX9} & \multicolumn{1}{c|}{TX8:9} &                            &                            &                            &                            &                            &                            &                            &                                                              &                                                              &                                                              &                                                              &                          &                          & \multicolumn{1}{c|}{}    & \multicolumn{1}{c|}{RXG} & \multicolumn{1}{c|}{TXG}  \\ 
            \cline{2-3}\cline{18-19}
            \textcolor[rgb]{0.1,1,0.2}{\textbf{N9}} & \multicolumn{1}{c|}{TX9} &                            &                            &                            &                            &                            &                            &                            &                            &                                                              &                                                              &                                                              &                                                              &                          &                          &                          & \multicolumn{1}{c|}{}    & \multicolumn{1}{c|}{RXG}  \\
            \cline{2-2}\cline{19-19}
        \end{tabular}
    }
    \caption{Model sense missatge de sincronització, amb dades acumulatives}
    \label{fig:noSyncAcumulatiu}
\end{figure}

\listoftables
\listoffigures

\printbibliography


% Si feu servir apèndixs, descomenteu
% (també la  \part del principi del document)
%\appendix
%\part{Apèndixs}
%\chapter{Un apèndix}


% ABANS D'ENTREGAR MIRAR QUE L·L ESTIGUIN BEN ESCRITES AMB \l.l

% TODO:
% FALTA EXPLICAR QUE POTÈNCIA D'ENVIAMENT ACK DEPEN DEL NOMBRE DE REINTENTS DEL FRAME REBUT A CAPA MAC

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-biblatex-use-Biber: t
%%% End:
